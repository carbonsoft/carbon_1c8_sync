Перем WinHttpRequest;
перем xml_fso;

Перем тСчетаДляВыгрузки;

Перем КолЗапСинхр;
Перем тСинхронизации; 

Перем мВалютаРегламентированногоУчета;
//перем xml_file;

// 1С:JSON. JavaScript Object Notation парсер и сериализатор.

// Copyright © 2010-2013 Александр Переверзев

// Данная лицензия разрешает лицам, получившим копию данного программного 
// обеспечения и сопутствующей документации (в дальнейшем именуемыми «Программное 
// Обеспечение»), безвозмездно использовать Программное Обеспечение без ограничений, 
// включая неограниченное право на использование, копирование, изменение, 
// добавление, публикацию, распространение, сублицензирование и/или продажу копий 
// Программного Обеспечения, также как и лицам, которым предоставляется данное 
// Программное Обеспечение, при соблюдении следующих условий:

// Указанное выше уведомление об авторском праве и данные условия должны быть 
// включены во все копии или значимые части данного Программного Обеспечения.

// ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО 
// ГАРАНТИЙ, ЯВНО ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ 
// ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И 
// ОТСУТСТВИЯ НАРУШЕНИЙ ПРАВ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ 
// ОТВЕТСТВЕННОСТИ ПО ИСКАМ О ВОЗМЕЩЕНИИ УЩЕРБА, УБЫТКОВ ИЛИ ДРУГИХ ТРЕБОВАНИЙ ПО 
// ДЕЙСТВУЮЩИМ КОНТРАКТАМ, ДЕЛИКТАМ ИЛИ ИНОМУ, ВОЗНИКШИМ ИЗ, ИМЕЮЩИМ ПРИЧИНОЙ ИЛИ 
// СВЯЗАННЫМ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ 
// ИЛИ ИНЫМИ ДЕЙСТВИЯМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.


// Александр Переверзев
// e-mail: a.v.pereverzev@gmail.com
// Версия: 2.0.0.17


// Особенности:
//	Парсер и сериализатор поддерживают два режима (формата) работы:
//		- Стандартный – полная поддержка стандарта JSON (подробнее см. <http://www.JSON.org/> и 
//		  <http://www.ietf.org/rfc/rfc4627.txt?number=4627>);
//		- Альтернативный – направлен на применение в проектах подразумевающих постоянный двусторонний
//		  обмен данными, по каналам связи Интернет, и требующих повышенную скорость обработки данных,
//		  минимизацию пересылаемых пакетов данных и однозначную идентификацию ссылочных типов во входящих данных.
//
//	Независимо от режима работы сериализатор, по требованию (см. Настройки), позволяет автоматически передавать 
//	не только уникальный идентификатор ссылки, но и ее представление, а парсер в свою очередь, 
//	анализируя входные данные, опускает представления ссылок, не включая их в результирующий набор данных.
//
//	При работе с проектами, в исходящих строковых данных которых не гарантируется отсутствие символов из диапазонов:
//		[0x007f, 0x009f], 0x00ad, [0x0600, 0x0604], 0x070f, [0x17b4, 0x17b5], 
//		[0x200c, 0x200f], [0x2028, 0x202f] [0x2060, 0x206f], 0xfeff, [0xfff0, 0xffff], 
//	рекомендуется не отключать настройку (см. Настройки) полного маскирования символов 
//	(подробнее см. <https://github.com/douglascrockford/JSON-js/blob/master/json2.js> и <http://sadesign.ru/tools/unicode>).
//
//	Независимо от режима работы сериализатор, по требованию (см. Настройки), может маскировать кириллические символы 
//	современных алфавитов славянских языков "АБВГҐДЂЃЕЀЁЄЖЗЅИЍІЇЙЈКЛЉМНЊОПРСТЋЌУЎФХЦЧЏШЩЪЫЬЭЮЯ" (включая нижний регистр) 
//	(подробнее см. <http://ru.wikipedia.org/wiki/Кириллица> и <http://ru.wikipedia.org/wiki/Кириллица_в_Юникоде>).
//
//	Поддерживаются все среды исполнения с ограничением сериализуемых типов. Используется кроссплатформенный код.



// История изменения:
//	Версия 2.0.0.17:
//		- (Новое) Маскирование кириллических символов современных алфавитов славянских языков (по требованию);
//		- (Новое) Поддержка сериализатором типов: ДвоичныеДанные, Картинка, ХранилищеЗначения;
//		- (Изменение) Рефакторинг переменных и процедур;
//		- (Исправление) Сериализация типа COMSafeArray;
//		- (Исправление) Удалены лишние ключевые слова "Экспорт".
//		- (Оптимизация) Уменьшение проверок связанных с режимом и параметрами парсинга и сериализцаии;
//		- (Оптимизация) Проверка необходимости анализа форматирования вынесена из процедуры анализа форматирования;
//		- (Оптимизация) Изменен алгоритм автоматического приведение объекта к структуре или соответствию в зависимости от имен свойств;
//		- (Оптимизация) Отказ от явного приведения типов в пользу неявного в операторах условий;
//		- (Оптимизация) Отказ от оператора "Попытка Исключение" при преобразовании строки к уникальному идентификатору;
//		- (Оптимизация) Изменен порядок проверки типов при парсинге.
//	Версия 2.0.0.15
//		- Релиз.



// Методы:
//	ПрочитатьJSON – парсер;
//	ЗаписатьJSON – сериализатор.

// Настройки и параметры:
//
//	Параметры функций:
//		Стандарт – определяет режим работы парсера и сериализатора:
//			- Истина		– стандартный режим (значение по умолчанию);
//			- Ложь			– альтернативный режим;
//			- Неопределено	– автоматическое определение режима входящих данных
//							  (только парсер, не рекомендуется – влияет на производительность).
//
//		ПредставленияСсылок – позволяет автоматически передавать не только значение ссылки, но и ее представление:
//			- Истина		- ссылка парсится и сериализуется как объект с двумя свойствами "Ссылка" и "Представление";
//			- Ложь			- ссылка парсится и сериализуется как уникальный идентификатор ссылки (значение по умолчанию);
//			- Неопределено	– автоматическое определение формата ссылок во входящих данных
//							  (только парсер, не рекомендуется – влияет на производительность).
//
//	Настройки:
//		АвтоматическоеПриведениеОбъектаКСтруктуре – автоматическое приведение объекта к структуре, а не к соответствию.
//			Настройка изменяется в функции "АвтоматическоеПриведениеОбъектаКСтруктуре" (по умолчанию отключена).
//			Автоматическое приведение к структуре выполняется только для объектов имена свойств, которых могут быть 
//			использованы как ключи структуры, все остальные объекты преобразуются в соответствие.
//
//		ПолноеМаскированиеСимволов – маскирование символов некорректно обрабатываемых JavaScript-ом.
//			Настройка изменяется в функции "НастройкаПолноеМаскированиеСимволов" (по умолчанию включена).
//			Не рекомендуется к использованию, так как влияет на производительность, но гарантирует безопасную передачу данных.
//			Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
//		МаскированиеКириллицы – маскирование кириллических символов современных алфавитов славянских языков.
//			Настройка изменяется в функции "НастройкаМаскированиеКириллицы" (по умолчанию отключена).
//			Не рекомендуется к использованию, так как влияет на производительность.
//			Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
//		НеявноеПриведениеПримитивныхЗначенийКлюча – неявное приведение примитивных значений ключей соответствий к строке.
//			Настройка изменяется в функции "НеявноеПриведениеПримитивныхЗначенийКлюча" (по умолчанию отключена).


// Альтернативный режим:
//		- Не поддерживается форматирование, как во входящих, так и в исходящих данных;
//		- Сериализация ссылочных типов в строковое служебное представление.


// Приятности:
//	Парсер:
//		- Устойчивость к некорректным данным и не подверженность injection атакам;
//		- Продвинутый синтаксический анализатор (указывает место и тип ошибки в данных);
//		- Поддержка форматирования во входящих данных (только стандартный режим);
//		- Безопасный разбор форматирования - незамаскированные символы форматирования в строковых значениях не будут утеряны;
//		- Поддержка строк в одинарных и в двойных кавычках;
//		- Автоматическое приведение объекта к структуре или соответствию в зависимости от имен свойств¹;
//		- Автоматическое преобразование к типу Дата строки вида "9999-99-99T99:99:99Z";
//		- Автоматическое преобразование к типу УникальныйИдентификатор строки вида "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
//		- Автоматического определение режима (стандартного или альтернативного) входящих данных;
//		- Автоматического определение необходимости отсечения представления ссылок;
//		- Однозначная идентификация ссылок (только альтернативный режим).
//	Сериализатор:
//		- Поддержка форматирования исходящих данных (только стандартный режим);
//		- Широкий состав сериализуемых типов данных, в том числе ссылок;
//		- Автоматическое приведение значений ключей соответствий к строковому представлению в формате 1С²;
//		- Автоматическое преобразование неподдерживаемых типов к строке;
//		- Маскирование кириллических символов современных алфавитов славянских языков;
//		- Нечувствительность к локализации³.
// ----
//  ¹ Если все имена свойства входящего объекта могут быть использованы как ключи структуры, 
//    то такой объект будет автоматически приведен к структуре, а не к соответствию. Управляется настройкой.
//  ² Управляется настройкой.
//  ³ При сериализации некоторых типов, исходящие объекты которых имеют обязательные свойства, 
//    такие представления и имена таких свойств всегда имеют русскую локализацию.


// Неприятности:
//		- Нестандартно форматированный код (Alt+Shift+F в помощь) на гране читаемости; 
//		- Сериализатор ориентирован, на средние-крупные пакеты данных.

// Сериализуемые типы:
//	Сервер, толстый клиент, тонкий клиент, веб-клиент:
//		- Неопределено;
//		- Null;
//		- Примитивные типы (все);
//		- Универсальные коллекции значений (клиентские);
//		- УникальныйИдентификатор;
//		- ДвоичныеДанные;
//		- Картинка.
//	Сервер, толстый клиент:
//		- Универсальные коллекции значений (серверные);
//		- ЛюбаяСсылка;
//		- Запрос;
//		- РезультатЗапроса;
//		- ВыборкаИзРезультатаЗапроса;
//		- ПостроительЗапроса;
//		- ПостроительОтчета;
//		- ХранилищеЗначения.
//	Сервер:
//		- ДанныеФормыКоллекция;
//		- ДанныеФормыСтруктураСКоллекцией;
//		- ДанныеФормыДерево.

// Порядок сериализации типов:
//		- Неопределено - сериализуется как Null;
//		- Null - согласно стандарту;
//		- Примитивные типы - согласно стандарту;
//		- Массивы и COMSafeArray - массив, согласно стандарту:
//				[ Значение, ... ]
//
//		- Структуры и соответствия – объект, согласно стандарту;
//				{ Ключ:Значение, ... }
//
//		- СписокЗначений - массив объектов с тремя свойствами "Значение", "Представление" и "Пометка";
//				[ { "Значение":Значение, "Представление":Представление, "Пометка":Пометка }, ... ]
//
//		- КлючИЗначение - объект с двумя свойствами "Ключ" и "Значени";
//				{ "Ключ":Ключ, "Значение":Значение }
//
//		- ТаблицаЗначений - массив объектов: 
//				[ { Колонка:Значение, ... }, ... ]
//
//		- ДеревоЗначений - массив объектов с обязательным свойством "Строки":
//				[ { Колонка:Значение, ... , "Строки":[ { Колонка:Значение, ... , "Строки":[ ... ] } , ... ] }, ... ]
//
//		- УникальныйИдентификатор - приведение к строке вида "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
//
//		- ЛюбаяСсылка:
//			- Стандартный режим - получение уникального идентификатора ссылки (в том числе и для перечислений) и его сериализация;
//			- Альтернативный режим - приведение к строке служебного вида "¦ref¦ ... ¦";
//
//		  При сериализации ссылок в режиме автоматически передачи не только сериализованного значения ссылки, 
//		  но и ее представления. Каждая ссылка передается как объект с двумя свойствами "Ссылка" и "Представление";
//				{ "Ссылка":Ссылка, "Представление":Представление }
//
//		- Запрос - автоматически выполняется и сериализуется как таблица значений;
//		- РезультатЗапроса - сериализуется как таблица значений;
//		- ВыборкаИзРезультатаЗапроса - сериализуется как структура значений текущей запись результата запроса;
//		- ПостроительЗапроса - автоматически выполняется и сериализуется как таблица значений;
//		- ПостроительОтчета - автоматически выполняется и сериализуется как таблица значений;
//		- ДанныеФормыКоллекция - сериализуется как таблица значений;
//		- ДанныеФормыСтруктураСКоллекцией - сериализуется как таблица значений;
//		- ДанныеФормыДерево - сериализуется как дерево значений;
//		- ДвоичныеДанные - кодируется по алгоритму base64¹ и сериализуется как строка;
//		- Картинка - автоматически преобразуется и сериализуется как двоичные данные;
//		- ХранилищеЗначения - автоматически извлекается сохраненное значение и сериализуется в зависимости от типа извлеченного значения.
// ----
//  ¹ Следуя рекомендациям стандарта, сериализатор при кодировании по алгоритму base64, не добавляет переводы строк 
//    в результирующие данные (подробнее см. <http://tools.ietf.org/html/rfc4648#section-3.1>).

// Производительность:
//	Производительность парсера исключительно зависит от набора входящих данных, а также от наличия форматирования.
//	Наихудшим вариантом является форматированный массив чисел, наилучшим - неформатированный массив строк.
//
//	Intel Core 2 Duo T5870 @ 2GHz - форматированный массив со всеми приблизительно равномерно встречающимися типами данных:
//		Парсер:			35 Кбайт/с.
//		Сериализатор:	165 Кбайт/с.

// Примечание:
//	Мало комментариев - без комментариев.

// Всем удачного программирования :)


// ─────────────────────────────────────────────────────────────────────────────
//	JSON

// JSON парсер.
//
// Параметры:
//	Значение - Строка. Строка данных в формате JSON для парсинга;
//
//  Стандарт - Неопределено, Булево. Режим работы:
//		- Истина - стандартный режим (значение по умолчанию);
//		- Ложь - альтернативный режим;
//		- Неопределено - автоопределение режима;
//
//  ПредставленияСсылок - Неопределено, Булево. Режим передачи ссылочных типов, с их представлением или без:
//		- Истина - ссылки передаются вместе со своим представлением, как объекты с двумя свойствами содержащими саму ссылку и ее представление;
//		- Ложь - ссылки передаются без представления (значение по умолчанию).
//		- Неопределено - автоопределение режима.
// 
// Возвращаемое значение:
//  Набор данных согласно содержимому входящих данных. 
//
Функция ПрочитатьJSON(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь) Экспорт 
	
	Возврат jsonПрочитатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции // ПрочитатьJSON()

// JSON сериализатор.
//
// Параметры:
//	Значение. Набор данных сериализуемых в формат JSON;
//
//  Стандарт - Булево. Режим работы:
//		- Истина - стандартный режим (значение по умолчанию);
//		- Ложь - альтернативный режим;
//
//  ПредставленияСсылок - Булево. Режим передачи ссылочных типов, с их представлением или без:
//		- Истина - ссылки передаются вместе со своим представлением, как объекты с двумя свойствами содержащими саму ссылку и ее представление;
//		- Ложь - ссылки передаются без представления (значение по умолчанию).
// 
// Возвращаемое значение:
//  Строка. Строка данных в формате JSON согласно содержимому входящих данных. 
//
Функция ЗаписатьJSON(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь) Экспорт 
	
	Возврат jsonЗаписатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции // ЗаписатьJSON()

// Магия для urlencode

Функция КодСимволаASCII(Символ) 
   КодUNICODE = КодСимвола(Символ); 
   Если ((КодUNICODE > 1039) И (КодUNICODE < 1104)) Тогда 
       Возврат (КодUNICODE - 848); 
   ИначеЕсли КодUNICODE = 8470 Тогда 
       Возврат 185; 
   ИначеЕсли КодUNICODE = 1105 Тогда 
       Возврат 184; 
   ИначеЕсли КодUNICODE = 1025 Тогда 
       Возврат 168; 
   Иначе 
       Возврат КодUNICODE; 
   КонецЕсли; 
КонецФункции


Функция URLEncode( value )

    table = "%00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14" +
            "%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28" +
            "%29%2A%2B%2C%2D%2E%2F%30%31%32%33%34%35%36%37%38%39%3A%3B%3C" +
            "%3D%3E%3F%40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F%50" +
            "%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F%60%61%62%63%64" +
            "%65%66%67%68%69%6A%6B%6C%6D%6E%6F%70%71%72%73%74%75%76%77%78" +
            "%79%7A%7B%7C%7D%7E%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C" +
            "%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0" +
            "%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4" +
            "%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8" +
            "%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC" +
            "%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0" +
            "%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF";
    
    result = "";        
            
    length = СтрДлина( value );        
    
    Для i = 1 По  length Цикл        
        symbol = Сред( value, i, 1 );        
       //code = КодСимвола( symbol );    
        code = КодСимволаASCII( symbol );
        result = result + Сред( table, code*3 + 1, 3 );        
    КонецЦикла;
    
    
    
    Возврат result;
КонецФункции

// Конец магии

// ─────────────────────────────────────────────────────────────────────────────
//  НАСТРОЙКИ

// Функция управляющая настройкой "АвтоматическоеПриведениеОбъектаКСтруктуре".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется автоматическое приведение объекта к структуре; 
//		- Ложь - автоматическое приведение объекта к структуре не выполняется, все объекты преобразуются в соответствие. 
//
// Примечание:
//  Автоматическое приведение к структуре выполняется только для объектов имена свойств которых могут быть 
//  использованы как ключи структуры, все остальные объекты преобразуются в соответствие.
//
Функция НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()
	
	Возврат Ложь;	// Измените для использования автоматического приведения объекта к структуре.
	
КонецФункции // НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()

// Функция управляющая настройкой "ПолноеМаскированиеСимволов".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется полное маскирование символов некорректно обрабатываемых JavaScript-ом; 
//		- Ложь - маскирование выполняется только согласно стандарту и дополнительно маскируются специальные символы. 
//
// Примечание:
//	Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
Функция НастройкаПолноеМаскированиеСимволов()
	
	Возврат Истина;	// Измените для неполного маскирования символов.
	
КонецФункции // НастройкаПолноеМаскированиеСимволов()

// Функция управляющая настройкой "МаскированиеКириллицы".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется маскирование кириллических символов; 
//		- Ложь - маскирование выполняется только согласно стандарту и дополнительно маскируются специальные символы. 
//
// Примечание:
//	Маскирование специальных символов из диапазона [0x0000, 0x001f] выполняется в не зависимости от настройки.
//
Функция НастройкаМаскированиеКириллицы()
	
	Возврат Ложь;	// Измените для маскирования кириллических символов.
	
КонецФункции // НастройкаМаскированиеКириллицы()

// Функция управляющая настройкой "НеявноеПриведениеПримитивныхЗначенийКлюча".
//
// Возвращаемое значение:
//  Булево. Значение настройки:
//		- Истина - выполняется неявное приведение примитивных типов значений ключей соответствий к их строковому представлению в формате 1С; 
//		- Ложь - неявное приведение примитивных типов значений ключей соответствий к строковому представлению не выполняется. 
//
// Примечание:
//	Неявно приводимые типы: Null, Булево, Число, Дата, Строка, УникальныйИдентификатор.
//
Функция НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()
	
	Возврат Ложь;	// Измените для использования неявного приведения примитивных значений ключей соответствий к строке.
	
КонецФункции // НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()


// ─────────────────────────────────────────────────────────────────────────────
//  ПАРСЕР

Функция jsonПрочитатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	// Проверка параметров.
	Если (Не Стандарт = Истина) И (Не Стандарт = Ложь) И (Не Стандарт = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("Стандарт"); КонецЕсли; 
	Если (Не ПредставленияСсылок = Истина) И (Не ПредставленияСсылок = Ложь) И (Не ПредставленияСсылок = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("ПредставленияСсылок"); КонецЕсли; 
	
	// Использование более общего случая параметров.
	Альтернативный = (Стандарт = Неопределено) Или (Не Стандарт); Стандарт = (Стандарт = Неопределено) Или Стандарт; ПредставленияСсылок = (ПредставленияСсылок = Неопределено) Или ПредставленияСсылок;
	
	// Схема подстановок шестнадцатиричной системы.
	СхемаПодстановок = Новый Соответствие; ШестнадцатиричнаяСистема = "0123456789abcdef"; ДесятичноеЧисло = 0;
	Для ВторойРазряд = 1 По 16 Цикл Для ПервыйРазряд = 1 По 16 Цикл СхемаПодстановок.Вставить(Сред(ШестнадцатиричнаяСистема, ВторойРазряд, 1) + Сред(ШестнадцатиричнаяСистема, ПервыйРазряд, 1), ДесятичноеЧисло); ДесятичноеЧисло = ДесятичноеЧисло + 1; КонецЦикла; КонецЦикла;
	
	// Вспомогательные данные.
	ВспомогательныеДанные = Новый Структура("ТипСтроки,СхемаПодстановок,АвтоматическиПриводитьКСтруктуре",
		Тип("Строка"),
		СхемаПодстановок,
		(НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре() = Истина));
		
	// Стартовые значения.
	Индекс = 1; Длина = СтрДлина(Значение);
	
	// Форматирование (первый шаг парсера).
	Если Стандарт Тогда СимволыФорматирования = " " + Символы.ВК + Символы.ПС + Символы.Таб; jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли;
	Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеПустойПакетДанных(); КонецЕсли; 
	
	// Парсер.
	Возврат jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Истина);
	
КонецФункции // jsonПрочитатьИнициализация()

Функция jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, ПервыйУровень)
	
	Символ = Сред(Значение, Индекс, 1);
	Если (Символ = """") Или (Символ = "'") Тогда        																	// " , '
		
		// Строка.
		Подстрока = Сред(Значение, Индекс + 1); Начало = Индекс; Пока Истина Цикл
			Позиция = Найти(Подстрока, Символ);
			
			Если (Позиция > 0) Тогда
				Индекс = Индекс + Позиция; Откат = Позиция - 1; Маскировка = Ложь; Пока (Сред(Подстрока, Откат, 1) = "\") И Откат Цикл Маскировка = Не Маскировка; Откат = Откат - 1; КонецЦикла;
				Если Маскировка Тогда Подстрока = Сред(Подстрока, Позиция + 1); Иначе Прервать; КонецЕсли;
			Иначе
		  		ВызватьИсключение ИсключениеНеожиданноеОкончаниеПакетаДанных();
			КонецЕсли;
			
		КонецЦикла;
		
		// Строка.
		Результат = jsonПрочитатьСтроку(Сред(Значение, Начало + 1, Индекс - Начало - 1), Стандарт, Начало, ВспомогательныеДанные.СхемаПодстановок, (Символ = "'"));
		
		Если jsonПрочитатьОпределитьДату(Результат) Тогда
			// Дата.
			Результат = jsonПрочитатьДату(Результат, Начало);
		ИначеЕсли jsonПрочитатьОпределитьИдентификатор(Результат) Тогда
			// Идентификатор.
			Результат = jsonПрочитатьИдентификатор(Результат, Начало);
		Иначе
			Если Альтернативный И jsonПрочитатьОпределитьВнутреннийТип(Результат) Тогда
				// Внутренний тип.
				Результат = jsonПрочитатьВнутреннийТип(Результат, Начало);
			КонецЕсли;
		КонецЕсли;
		
		// Корректировка индекса.
		Индекс = Индекс + 1;
		
	ИначеЕсли (Символ = "[") Тогда																							// [
		
		// Массив.
		Результат = Новый Массив;
		
		Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
		Символ = Сред(Значение, Индекс, 1); Если (Символ = "]") Тогда														// ] 
			
			// Пустой массив.
			Индекс = Индекс + 1;
		
		Иначе
		
			Пока (Индекс <= Длина) Цикл
				
				// Значение.
				Результат.Добавить(jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь));
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "]") Тогда																					// ]
					// Окончание массива.
					Индекс = Индекс + 1; Прервать;
				Иначе
					// Продолжение массива.
					Если (Символ = ",") Тогда																				// ,
						Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
					Иначе
						ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ",");
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	ИначеЕсли (Символ = "{") Тогда																							// {
	
		// Объект.
		Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеМассива(Длина); КонецЕсли;
		Символ = Сред(Значение, Индекс, 1); Если (Символ = "}") Тогда														// } 
			
			// Пустой объект.
			Индекс = Индекс + 1;
			
			// Структура или соответствие.
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда Результат = Новый Структура; Иначе Результат = Новый Соответствие; КонецЕсли; 
		
		Иначе
			
			Результат = Новый Соответствие;
			
			ТипСтроки = ВспомогательныеДанные.ТипСтроки; Пока (Индекс <= Длина) Цикл
				
				// Ключ.
				Начало = Индекс; КлючЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь); Если (Не ТипЗнч(КлючЭлемента) = ТипСтроки) Тогда ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Начало, КлючЭлемента); КонецЕсли;
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = ":") Тогда																					// :
					Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеОбъетка(Длина); КонецЕсли;
				Иначе
					ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ":");
				КонецЕсли;
				
				// Значение.
				ЗначениеЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь);
				
				// Коллекция.
				Результат.Вставить(КлючЭлемента, ЗначениеЭлемента);
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "}") Тогда																					// }
					// Окончание объекта.
					Индекс = Индекс + 1; Прервать;
				Иначе
					// Продолжение объекта.
					Если (Символ = ",") Тогда																				// ,
						Индекс = Индекс + 1; Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если (Индекс >= Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеОбъетка(Длина); КонецЕсли;
					Иначе
						ВызватьИсключение ИсключениеНедопустимыйСимвол(Индекс, ",");
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
			// Структура или соответствие.
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда
				
				РезультатСтруктура = Новый Структура; 
				Для Каждого Элемент Из Результат Цикл Попытка РезультатСтруктура.Вставить(Элемент.Ключ, Элемент.Значение); Исключение РезультатСтруктура = Результат; АвтоматическоеПриведениеНеВыполнено = Истина; Прервать; КонецПопытки; КонецЦикла;
				Результат = РезультатСтруктура;
				
				// Ссылка.
				Если ПредставленияСсылок Тогда Результат = jsonПрочитатьСсылку(Результат, (АвтоматическоеПриведениеНеВыполнено = Истина)); КонецЕсли;
				
			Иначе
				
				// Ссылка.
				Если ПредставленияСсылок Тогда Результат = jsonПрочитатьСсылку(Результат, Истина); КонецЕсли;
				
			КонецЕсли; 
		
		КонецЕсли;
		
	Иначе
	
		// Остальные примитивные типы.
		Если (Символ = "n") Тогда
			
			// Null.
			Если (Сред(Значение, Индекс, 4) = "null") Тогда Индекс = Индекс + 4; Результат = Null; Иначе ВызватьИсключение ИсключениеНекорректныйТипNull(Индекс); КонецЕсли;
			
		ИначеЕсли (Символ = "t") Тогда
			
			// Истина.
			Если (Сред(Значение, Индекс, 4) = "true") Тогда Индекс = Индекс + 4; Результат = Истина; Иначе ВызватьИсключение ИсключениеНекорректныйТипБулево(Индекс); КонецЕсли;
			
		ИначеЕсли (Символ = "f") Тогда
			
			// Ложь.
			Если (Сред(Значение, Индекс, 5) = "false") Тогда Индекс = Индекс + 5; Результат = Ложь; Иначе ВызватьИсключение ИсключениеНекорректныйТипБулево(Индекс); КонецЕсли;
			
		ИначеЕсли (Символ = "u") Тогда
			
			// Неопределено.
			Если (Сред(Значение, Индекс, 9) = "undefined") Тогда Индекс = Индекс + 9; Результат = Неопределено; Иначе ВызватьИсключение ИсключениеНекорректныйТипНеопределено(Индекс); КонецЕсли;
			
		Иначе
			
			// Число.
			Начало = Индекс; Пока Найти("-+0123456789.", Символ) И (Индекс <= Длина) Цикл Индекс = Индекс + 1; Символ = Сред(Значение, Индекс, 1); КонецЦикла;
			
			// Преобразование числа.
			Попытка
				Результат = Число(Сред(Значение, Начало, Индекс - Начало));
			Исключение
				ВызватьИсключение ИсключениеНекорректныйФорматЧисла(Начало, Сред(Значение, Начало, Индекс - Начало)); 
			КонецПопытки;
			
			// Экспоненциальная часть.
			Если (Символ = "E") Или (Символ = "e") Тогда
				
				// Степень.
				Индекс = Индекс + 1; Позиция = Индекс; Символ = Сред(Значение, Индекс, 1); Пока Найти("-+0123456789", Символ) И (Индекс <= Длина) Цикл Индекс = Индекс + 1; Символ = Сред(Значение, Индекс, 1); КонецЦикла;
				
				// Преобразование степени.
				Попытка
					Степень = Число(Сред(Значение, Позиция, Индекс - Позиция));
				Исключение
					ВызватьИсключение ИсключениеНекорректныйФорматЧисла(Начало, Сред(Значение, Начало, Индекс - Начало)); 
				КонецПопытки;
				
				// Возвидение числа в степень.
				Результат = Результат * Pow(10, Степень);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Форматирование.
	Если Стандарт Тогда jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования); КонецЕсли; Если ПервыйУровень Тогда Если (Индекс <= Длина) Тогда ВызватьИсключение ИсключениеНекорректныйПакетДанных(Индекс); КонецЕсли; Иначе Если (Индекс > Длина) Тогда ВызватьИсключение ИсключениеНеожиданноеОкончаниеПакетаДанных(); КонецЕсли; КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // jsonПрочитать()

Функция jsonПрочитатьОпределитьДату(Значение)

	// Проверка.
	Если (СтрДлина(Значение) = 20) Тогда
		Если (Сред(Значение, 05, 1) = "-") И				// -
			 (Сред(Значение, 08, 1) = "-") И				// -
			 (Сред(Значение, 11, 1) = "T") И				// T
			 (Сред(Значение, 14, 1) = ":") И				// :
			 (Сред(Значение, 17, 1) = ":") И				// :
			 (Сред(Значение, 20, 1) = "Z") Тогда			// Z
			// Год. 
			Если Найти("0123456789", Сред(Значение, 01, 1)) И
				 Найти("0123456789", Сред(Значение, 02, 1)) И
				 Найти("0123456789", Сред(Значение, 03, 1)) И
				 Найти("0123456789", Сред(Значение, 04, 1)) И
			// Месяц.
				 Найти("0123456789", Сред(Значение, 06, 1)) И
				 Найти("0123456789", Сред(Значение, 07, 1)) И
			// День.
				 Найти("0123456789", Сред(Значение, 09, 1)) И
				 Найти("0123456789", Сред(Значение, 10, 1)) И
			// Час.
				 Найти("0123456789", Сред(Значение, 12, 1)) И
				 Найти("0123456789", Сред(Значение, 13, 1)) И
			// Минута.
				 Найти("0123456789", Сред(Значение, 15, 1)) И
				 Найти("0123456789", Сред(Значение, 16, 1)) И
			// Секунда.
				 Найти("0123456789", Сред(Значение, 18, 1)) И
				 Найти("0123456789", Сред(Значение, 19, 1)) Тогда
				Возврат Истина; 
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // jsonПрочитатьОпределитьДату()

Функция jsonПрочитатьОпределитьИдентификатор(Значение)

	// Проверка.
	Если (СтрДлина(Значение) = 36) Тогда
		Если (Сред(Значение, 09, 1) = "-") И					// -
			 (Сред(Значение, 14, 1) = "-") И					// -
			 (Сред(Значение, 19, 1) = "-") И					// -
			 (Сред(Значение, 24, 1) = "-") Тогда				// -
			// Первая часть. 
			Для Индекс = 01 По 08 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Вторая часть. 
			Для Индекс = 10 По 13 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Третья часть. 
			Для Индекс = 15 По 18 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Четвертая часть. 
			Для Индекс = 20 По 23 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			// Пятая часть. 
			Для Индекс = 25 По 36 Цикл Если Не Найти("0123456789ABCDEFabcdef", Сред(Значение, Индекс, 1)) Тогда Возврат Ложь; КонецЕсли; КонецЦикла;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // jsonПрочитатьОпределитьИдентификатор()

Функция jsonПрочитатьОпределитьВнутреннийТип(Значение)
	
	// Поиск.
	Возврат (Лев(Значение, 1) = "¦") И (Сред(Значение, 5, 1) = "¦") И (Прав(Значение, 1) = "¦"); // ¦xxx¦ ... ¦
	
КонецФункции // jsonПрочитатьОпределитьВнутреннийТип()

Функция jsonПрочитатьСтроку(Значение, Стандарт, Индекс, СхемаПодстановок, ОдинарнаяКавычка)
	
	// Последоавтельность перемаскировки.
	ПоследоавтельностьПеремаскировки = "\" + Символ(65535);
	
	// Демаскирование служебных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение, 
						"\\",			ПоследоавтельностьПеремаскировки),		// Перемаскирование последовательности.
						"\/",			"/"),           // x2f
						"\b",			Символ(008)),	// x08
						"\t",			Символы.Таб),   // x09
						"\n",			Символы.ПС),    // x0a
						"\f",			Символы.ПФ),    // x0c
						"\r",			Символы.ВК),    // x0d
						"\""",			"""");          // x22
						
	// Демаскирование Юникод символов.
	Позиция = Найти(Результат, "\u"); Пока Позиция Цикл
		СтаршийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 2, 2))]; МладшийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 4, 2))]; Если (СтаршийБайт = Неопределено) Или (МладшийБайт = Неопределено) Тогда ВызватьИсключение ИсключениеНекорректныйФорматСтроки(Индекс); КонецЕсли;
		Результат = СтрЗаменить(Результат, Сред(Результат, Позиция, 6), Символ(256 * СтаршийБайт + МладшийБайт)); Позиция = Найти(Результат, "\u");
	КонецЦикла;
		
	// Одинарная кавычка.
	Если ОдинарнаяКавычка Тогда Результат = СтрЗаменить(Результат, "\'", "'"); КонецЕсли;
	
	// Демаскирование перемаскированой последовательности.
	Возврат СтрЗаменить(Результат, ПоследоавтельностьПеремаскировки, "\");				
						
КонецФункции // jsonПрочитатьСтроку()

Функция jsonПрочитатьДату(Значение, Индекс)
	
	// Поиск.
	Попытка
		Возврат Дата(Лев(Значение, 4) + Сред(Значение, 06, 2) + Сред(Значение, 09, 2) + 
					 Сред(Значение, 12, 2) + Сред(Значение, 15, 2) + Сред(Значение, 18, 2));
	Исключение
		ВызватьИсключение ИсключениеНекорректныйФорматДаты(Индекс, Значение);
	КонецПопытки;
	
КонецФункции // jsonПрочитатьДату()

Функция jsonПрочитатьСсылку(Значение, Соответствие)
	
	Перем Ссылка;
	
	// Ссылка.
	Если (Значение.Количество() = 2) Тогда 
		Если Соответствие Тогда
			Ссылка = Значение.Получить("Ссылка"); Если (Не Ссылка = Неопределено) И (Не Значение.Получить("Представление") = Неопределено) Тогда Возврат Ссылка; КонецЕсли;
		Иначе
			Если Значение.Свойство("Представление") И Значение.Свойство("Ссылка", Ссылка) Тогда Возврат Ссылка; КонецЕсли;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат Значение;
	
КонецФункции // jsonПрочитатьСсылку()

Функция jsonПрочитатьИдентификатор(Значение, Индекс)
	
	// Поиск.
	Возврат Новый УникальныйИдентификатор(Значение);
	
КонецФункции // jsonПрочитатьИдентификатор()

Функция jsonПрочитатьВнутреннийТип(Значение, Индекс)
#Если ВебКлиент Или ТонкийКлиент Тогда
	ВызватьИсключение ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте(Индекс, Значение);
#Иначе
	
	// Поиск.
	Тип = Сред(Значение, 2, 3); Данные = Сред(Значение, 6, СтрДлина(Значение) - 6);
	
	Если (Тип = "ref") Тогда
		Попытка
			Возврат ЗначениеИзСтрокиВнутр("{""#""," + СтрЗаменить(СтрЗаменить(Данные, "×", ":"), "÷", ",") + "}");
		Исключение
			ВызватьИсключение ИсключениеНевозможноПреобразоватьЗначение(Индекс, Значение);
		КонецПопытки;
	КонецЕсли;
		
	ВызватьИсключение ИсключениеНеопознанныйТип(Индекс, Тип);
	
#КонецЕсли
КонецФункции // jsonПрочитатьВнутреннийТип()

Процедура jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования)
	
	// Пропуск форматирования.
	Пока (Индекс <= Длина) И Найти(СимволыФорматирования, Сред(Значение, Индекс, 1)) Цикл Индекс = Индекс + 1; КонецЦикла;
	// Пробел его не видно, \r, \n, \t .
	
КонецПроцедуры // jsonПрочитатьПропуститьФорматирование()


// ─────────────────────────────────────────────────────────────────────────────
//  СЕРИАЛИЗАТОР

Функция jsonЗаписатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	// Проверка параметров.
	Если (Не Стандарт = Истина) И (Не Стандарт = Ложь) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("Стандарт"); КонецЕсли; 
	Если (Не ПредставленияСсылок = Истина) И (Не ПредставленияСсылок = Ложь) Тогда ВызватьИсключение ИсключениеНекорректныйПараметр("ПредставленияСсылок"); КонецЕсли; 
	
	ВспомогательныеДанные = Новый Структура("ПримитивныеТипы,Массивы,Структуры,Соответсвия,Построители,КлиентскиеТипы,ТипДопустимыхКлючей", 
		Новый ОписаниеТипов("Null,Булево,Число,Дата,УникальныйИдентификатор"),									// ПримитивныеТипы.
		#Если ВебКлиент Или ТонкийКлиент Тогда
			Новый ОписаниеТипов("Массив,ФиксированныйМассив"),													// Массивы.
			Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура"),											// Структуры.
			Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура,Соответствие,ФиксированноеСоответствие"),		// Соответсвия.
		#Иначе
			#Если НаСервере Тогда
				Новый ОписаниеТипов("Массив,ФиксированныйМассив,ФиксированнаяКоллекция"),						// Массивы.
				Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура"),										// Структуры.
				Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура,Соответствие,ФиксированноеСоответствие"),	// Соответсвия.
			#Иначе
				Новый ОписаниеТипов("Массив,ФиксированныйМассив"),												// Массивы.
				Новый ОписаниеТипов("Структура"),																// Структуры.
				Новый ОписаниеТипов("Структура,Соответствие"),													// Соответсвия.
			#КонецЕсли
		#КонецЕсли
		#Если ВебКлиент Или ТонкийКлиент Тогда
			Неопределено,																						// Построители.
		#Иначе
			Новый ОписаниеТипов("ПостроительЗапроса,ПостроительОтчета"),										// Построители.
		#КонецЕсли
		#Если НаСервере Тогда
			Новый ОписаниеТипов("ДанныеФормыКоллекция,ДанныеФормыСтруктураСКоллекцией,ДанныеФормыДерево"),		// КлиентскиеТипы.
		#Иначе
			Неопределено,																						// КлиентскиеТипы.
		#КонецЕсли
		Новый ОписаниеТипов("Строка"));																			// ТипДопустимыхКлючей.
		
	// Типы допустимых ключей.
	Если (НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча() = Истина) Тогда ВспомогательныеДанные.ТипДопустимыхКлючей = Новый ОписаниеТипов("Null,Булево,Число,Дата,Строка,УникальныйИдентификатор"); КонецЕсли;
		
	// форматирование.
	Если Стандарт Тогда Смещение = ""; Отступ = " "; Табуляция = "    "; ПереносСтроки = Символы.ПС; Иначе Смещение = ""; Отступ = ""; Табуляция = ""; ПереносСтроки = ""; КонецЕсли;
	
	// Сериализация.
	Возврат jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, (НастройкаПолноеМаскированиеСимволов() = Истина), (НастройкаМаскированиеКириллицы() = Истина));
	
КонецФункции // jsonЗаписатьИнициализация()

Функция jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	// Определение типа.
	Тип = ТипЗнч(Значение);
		
	// Строка.
	Если (Тип = Тип("Строка")) Тогда Возврат jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Неопределено и примитивные типы.
	Если ВспомогательныеДанные.ПримитивныеТипы.СодержитТип(Тип) Тогда 
		#Если ВебКлиент Или ТонкийКлиент Тогда
		Если (Значение = Null) Или (Значение = Неопределено) Тогда Возврат "null"; ИначеЕсли (Тип = Тип("Дата")) Тогда Возврат """" + Формат(Значение, "ДФ=yyyy-MM-ddTHH:mm:ss; ДП=") + "Z""" ИначеЕсли (Тип = Тип("УникальныйИдентификатор")) Тогда Возврат """" + Значение + """"; Иначе Возврат Формат(Значение, "ЧРД=.; ЧН=; ЧГ=; БЛ=false; БИ=true"); КонецЕсли;
		#Иначе
		Если (Значение = Null) Или (Значение = Неопределено) Тогда Возврат "null"; ИначеЕсли (Тип = Тип("Дата")) Тогда Возврат """" + XMLСтрока(Значение) + "Z""" ИначеЕсли (Тип = Тип("УникальныйИдентификатор")) Тогда Возврат """" + XMLСтрока(Значение) + """"; Иначе Возврат XMLСтрока(Значение); КонецЕсли;
		#КонецЕсли
	КонецЕсли;
	
	// Структуры и строка дерева значений (структурой).
	Если ВспомогательныеДанные.Структуры.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
						
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
	
			Если (Колонки = Неопределено) Тогда
			
				// Структуры.
				Если МаскированиеКириллицы Тогда
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					
				Иначе
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					
				КонецЕсли;

			Иначе
			
				// Строка дерева значений (структурой).
				Если МаскированиеКириллицы Тогда
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если (Элемент.Ключ = "Строки") Тогда Продолжить; КонецЕсли;
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписатьСтроку(Элемент.Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы) + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + """\u0421\u0442\u0440\u043e\u043a\u0438"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """\u0421\u0442\u0440\u043e\u043a\u0438"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
					
				Иначе
					
					Первый = Истина; Для Каждого Элемент Из Значение Цикл
						Если (Элемент.Ключ = "Строки") Тогда Продолжить; КонецЕсли;
						Если Первый Тогда
							Результат = ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
						Иначе
							Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
						КонецЕсли;
					КонецЦикла;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + """Строки"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """Строки"":" + Отступ + jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
					
				КонецЕсли;

		    КонецЕсли;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
			
		Иначе
			
			// Пустая структура.
			Возврат "{}";
		
		КонецЕсли;
	КонецЕсли;
	
	// Соответсвия.
	Если ВспомогательныеДанные.Соответсвия.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
						
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
	
			// Соответсвия.
			ТипДопустимыхКлючей = ВспомогательныеДанные.ТипДопустимыхКлючей;
			
			Если МаскированиеКириллицы Тогда
				
				Первый = Истина; Для Каждого Элемент Из Значение Цикл
					Ключ = Элемент.Ключ; Если ТипДопустимыхКлючей.СодержитТип(ТипЗнч(Ключ)) Тогда Ключ = jsonЗаписатьСтроку(Строка(Ключ), ПолноеМаскированиеСимволов, МаскированиеКириллицы); Иначе ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Неопределено, Ключ); КонецЕсли;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
				КонецЦикла;
				
			Иначе
			
				Первый = Истина; Для Каждого Элемент Из Значение Цикл
					Ключ = Элемент.Ключ; Тип = ТипЗнч(Ключ); Если (Тип = Тип("Строка")) Тогда Ключ = jsonЗаписатьСтроку(Ключ, ПолноеМаскированиеСимволов, МаскированиеКириллицы); ИначеЕсли ТипДопустимыхКлючей.СодержитТип(Тип) Тогда Ключ = """" + Ключ + """"; Иначе ВызватьИсключение ИсключениеНедопустимыйТипКлюча(Неопределено, Ключ); КонецЕсли;
					Если Первый Тогда
						Результат = ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
					Иначе
						Результат = Результат + "," + ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					КонецЕсли;
				КонецЦикла;
				
			КонецЕсли;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
			
		Иначе
			
			// Пустое соответсвие.
			Возврат "{}";
		
		КонецЕсли;
	КонецЕсли;
	
	// Массивы.
	Если ВспомогательныеДанные.Массивы.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
						
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;

			Первый = Истина; Для Каждого Элемент Из Значение Цикл
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
		
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
		
		Иначе
			
			// Пустой массив.
			Возврат "[]";
		
		КонецЕсли;
	КонецЕсли;
	
	// Список значений.
	Если (Тип = Тип("СписокЗначений")) Тогда
		Если Значение.Количество() Тогда
						
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;

			Структура = Новый Структура("Значение,Представление,Пометка");
			Первый = Истина; Для Каждого Элемент Из Значение Цикл
				ЗаполнитьЗначенияСвойств(Структура, Элемент);
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
		
		Иначе
			
			// Пустой список значений.
			Возврат "[]";
		
		КонецЕсли;
	КонецЕсли;
	
	// Таблица значений.
	#Если ВебКлиент Или ТонкийКлиент Тогда
	#Иначе
	Если (Тип = Тип("ТаблицаЗначений")) Тогда
		Если Значение.Количество() Тогда
						
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
	
			Структура = Новый Структура; НаборКолонок = Значение.Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
			
			Первый = Истина; Для Каждого Элемент Из Значение Цикл
				ЗаполнитьЗначенияСвойств(Структура, Элемент);
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
				
		Иначе
			
			// Пустая таблица значений.
			Возврат "[]";
		
		КонецЕсли;
	КонецЕсли;
	
	// Коллекция строк дерева значений.
	Если (Тип = Тип("КоллекцияСтрокДереваЗначений")) Тогда
		Если Значение.Количество() Тогда
						
			// форматирование.
			СледующееСмещение = Смещение + Табуляция;
	
			Структура = Колонки; Первый = Истина; Для Каждого Элемент Из Значение Цикл
				ЗаполнитьЗначенияСвойств(Структура, Элемент); Структура.Строки = Элемент.Строки;
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
		
		Иначе
			
			// Пустая коллекция строк.
			Возврат "[]";
		
		КонецЕсли;
	КонецЕсли;
	
	// Дерево значений.
	Если (Тип = Тип("ДеревоЗначений")) Тогда
		
		Структура = Новый Структура("Строки"); НаборКолонок = Значение.Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
		Возврат jsonЗаписать(Значение.Строки, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Структура, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
		
	КонецЕсли;
	
	// Запрос.
	Если (Тип = Тип("Запрос")) Тогда Попытка Возврат jsonЗаписать(Значение.Выполнить().Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); Исключение ВызватьИсключение ИсключениеНевозможноВыполнитьЗапрос(ИнформацияОбОшибке().Причина.Описание); КонецПопытки; КонецЕсли;
	
	// Результат запроса.
	Если (Тип = Тип("РезультатЗапроса")) Тогда Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Выборка из результата запроса.
	Если (Тип = Тип("ВыборкаИзРезультатаЗапроса")) Тогда
		
		Структура = Новый Структура; НаборКолонок = Значение.Владелец().Колонки; Для Каждого Колонка Из НаборКолонок Цикл Структура.Вставить(Колонка.Имя); КонецЦикла;
		ЗаполнитьЗначенияСвойств(Структура, Значение);
		Возврат jsonЗаписать(Структура, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
		
	КонецЕсли;
	
	// Построители.
	Если ВспомогательныеДанные.Построители.СодержитТип(Тип) Тогда Попытка Значение.Выполнить(); Исключение ВызватьИсключение ИсключениеНевозможноВыполнитьЗапрос(ИнформацияОбОшибке().Причина.Описание); КонецПопытки; Возврат jsonЗаписать(Значение.Результат, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Хранилище значения.
	Если (Тип = Тип("ХранилищеЗначения")) Тогда Возврат jsonЗаписать(Значение.Получить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	#КонецЕсли
	
	// Двоичные данные.
	Если (Тип = Тип("ДвоичныеДанные")) Тогда
		#Если ВебКлиент Или ТонкийКлиент Тогда
		Возврат """" + СтрЗаменить(СтрЗаменить(СтрЗаменить(Base64Строка(Значение), Символы.ВК, ""), Символы.ПС, ""), "/", "\/") + """";
		#Иначе
		Возврат """" + СтрЗаменить(СтрЗаменить(СтрЗаменить(XMLСтрока(Значение), Символы.ВК, ""), Символы.ПС, ""), "/", "\/") + """";
		#КонецЕсли
	КонецЕсли;
	
	// Картинка.
	Если (Тип = Тип("Картинка")) Тогда
		#Если ВебКлиент Или ТонкийКлиент Тогда
		Возврат """" + СтрЗаменить(СтрЗаменить(СтрЗаменить(Base64Строка(Значение.ПолучитьДвоичныеДанные()), Символы.ВК, ""), Символы.ПС, ""), "/", "\/") + """";
		#Иначе
		Возврат """" + СтрЗаменить(СтрЗаменить(СтрЗаменить(XMLСтрока(Значение.ПолучитьДвоичныеДанные()), Символы.ВК, ""), Символы.ПС, ""), "/", "\/") + """";
		#КонецЕсли
	КонецЕсли;
	
	// Ключ и значение.
	Если (Тип = Тип("КлючИЗначение")) Тогда Возврат jsonЗаписать(Новый Структура("Ключ,Значение", Значение.Ключ, Значение.Значение), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Клиентские типы.
	#Если НаСервере Тогда
	Если ВспомогательныеДанные.КлиентскиеТипы.СодержитТип(Тип) Тогда
		Если (Тип = Тип("ДанныеФормыДерево")) Тогда
			Возврат jsonЗаписать(ДанныеФормыВЗначение(Значение, Тип("ДеревоЗначений")), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
		Иначе
			Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
		КонецЕсли;
	КонецЕсли;
	#КонецЕсли
	
	// COMSafeArray.
	#Если ВебКлиент Тогда
	#Иначе
	Если (Тип = Тип("COMSafeArray")) Тогда Возврат jsonЗаписать(Значение.Выгрузить(), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	#КонецЕсли
			
	// Ссылки.
	#Если ВебКлиент Или ТонкийКлиент Тогда
	#Иначе
	Перечисление = Перечисления.ТипВсеСсылки().СодержитТип(Тип);
	Если Перечисление Или
		 Справочники.ТипВсеСсылки().СодержитТип(Тип) Или
		 Документы.ТипВсеСсылки().СодержитТип(Тип) Или
		 ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Или
		 ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Или
		 ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Или
		 Задачи.ТипВсеСсылки().СодержитТип(Тип) Или
		 БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Или
		 БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип) Или
		 ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда 
		Возврат jsonЗаписатьСсылку(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Перечисление, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
	КонецЕсли;
	#КонецЕсли
	
	// Неподдерживаемые типы.
	Возврат jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы);

КонецФункции // jsonЗаписать()

Функция jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	// Маскирование служебных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение, 
						"\",			"\\"),			// x5c
						"/",			"\/"),			// x2f
						Символ(008),	"\b"),			// x08
						Символы.Таб,	"\t"), 			// x09
						Символы.ПС,		"\n"),			// x0a
						Символы.ПФ,		"\f"),			// x0c
						Символы.ВК,		"\r"),			// x0d
						"""",			"\""");			// x22

	// Маскирование специальных символов.
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(00),		"\u0000"),
						Символ(01),		"\u0001"),
						Символ(02),		"\u0002"),
						Символ(03),		"\u0003"),
						Символ(04),		"\u0004"),
						Символ(05),		"\u0005"),
						Символ(06),		"\u0006"),
						Символ(07),		"\u0007"),
						Символ(11),		"\u000b"),
						Символ(14),		"\u000e"),
						Символ(15),		"\u000f"),
						Символ(16),		"\u0010"),
						Символ(17),		"\u0011"),
						Символ(18),		"\u0012"),
						Символ(19),		"\u0013"),
						Символ(20),		"\u0014"),
						Символ(21),		"\u0015"),
						Символ(22),		"\u0016"),
						Символ(23),		"\u0017"),
						Символ(24),		"\u0018"),
						Символ(25),		"\u0019"),
						Символ(26),		"\u001a"),
						Символ(27),		"\u001b"),
						Символ(28),		"\u001c"),
						Символ(29),		"\u001d"),
						Символ(30),		"\u001e"),
						Символ(31),		"\u001f");
						
	Если ПолноеМаскированиеСимволов Тогда
							
		// Маскирование сиволов обрабатываемых JavaScript-ом не правильно.
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(127),	"\u007f"),
						Символ(128),	"\u0080"),
						Символ(129),	"\u0081"),
						Символ(130),	"\u0082"),
						Символ(131),	"\u0083"),
						Символ(132),	"\u0084"),
						Символ(133),	"\u0085"),
						Символ(134),	"\u0086"),
						Символ(135),	"\u0087"),
						Символ(136),	"\u0088"),
						Символ(137),	"\u0089"),
						Символ(138),	"\u008a"),
						Символ(139),	"\u008b"),
						Символ(140),	"\u008c"),
						Символ(141),	"\u008d"),
						Символ(142),	"\u008e"),
						Символ(143),	"\u008f"),
						Символ(144),	"\u0090"),
						Символ(145),	"\u0091"),
						Символ(146),	"\u0092"),
						Символ(147),	"\u0093"),
						Символ(148),	"\u0094"),
						Символ(149),	"\u0095"),
						Символ(150),	"\u0096"),
						Символ(151),	"\u0097"),
						Символ(152),	"\u0098"),
						Символ(153),	"\u0099"),
						Символ(154),	"\u009a"),
						Символ(155),	"\u009b"),
						Символ(156),	"\u009c"),
						Символ(157),	"\u009d"),
						Символ(158),	"\u009e"),
						Символ(159),	"\u009f"),
						Символ(173),	"\u00ad");
						
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(1536),	"\u0600"),
						Символ(1537),	"\u0601"),
						Символ(1538),	"\u0602"),
						Символ(1539),	"\u0603"),
						Символ(1540),	"\u0604"),
						Символ(1807),	"\u070f"),
						Символ(6068),	"\u17b4"),
						Символ(6069),	"\u17b5"),
						Символ(8204),	"\u200c"),
						Символ(8205),	"\u200d"),
						Символ(8206),	"\u200e"),
						Символ(8207),	"\u200f"),
						Символ(8232),	"\u2028"),
						Символ(8233),	"\u2029"),
						Символ(8234),	"\u202a"),
						Символ(8235),	"\u202b"),
						Символ(8236),	"\u202c"),
						Символ(8237),	"\u202d"),
						Символ(8238),	"\u202e"),
						Символ(8239),	"\u202f"),
						Символ(8288),	"\u2060"),
						Символ(8289),	"\u2061"),
						Символ(8290),	"\u2062"),
						Символ(8291),	"\u2063"),
						Символ(8292),	"\u2064"),
						Символ(8293),	"\u2065"),
						Символ(8294),	"\u2066"),
						Символ(8295),	"\u2067");
						
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						Символ(8296),	"\u2068"),
						Символ(8297),	"\u2069"),
						Символ(8268),	"\u206a"),
						Символ(8299),	"\u206b"),
						Символ(8300),	"\u206c"),
						Символ(8301),	"\u206d"),
						Символ(8302),	"\u206e"),
						Символ(8303),	"\u206f"),
						Символ(65279),	"\ufeff"),
						Символ(65520),	"\ufff0"),
						Символ(65521),	"\ufff1"),
						Символ(65522),	"\ufff2"),
						Символ(65523),	"\ufff3"),
						Символ(65524),	"\ufff4"),
						Символ(65525),	"\ufff5"),
						Символ(65526),	"\ufff6"),
						Символ(65527),	"\ufff7"),
						Символ(65528),	"\ufff8"),
						Символ(65529),	"\ufff9"),
						Символ(65530),	"\ufffa"),
						Символ(65531),	"\ufffb"),
						Символ(65532),	"\ufffc"),
						Символ(65533),	"\ufffd"),
						Символ(65534),	"\ufffe"),
						Символ(65535),	"\uffff");
	
	КонецЕсли;
					
	Если МаскированиеКириллицы Тогда
		
		// Маскирование кириллических символов.
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
                        "А",            "\u0410"),
                        "Б",            "\u0411"),
                        "В",            "\u0412"),
                        "Г",            "\u0413"),
                        "Д",            "\u0414"),
                        "Е",            "\u0415"),
                        "Ж",            "\u0416"),
                        "З",            "\u0417"),
                        "И",            "\u0418"),
                        "Й",            "\u0419"),
                        "К",            "\u041a"),
                        "Л",            "\u041b"),
                        "М",            "\u041c"),
                        "Н",            "\u041d"),
                        "О",            "\u041e"),
                        "П",            "\u041f"),
                        "Р",            "\u0420"),
                        "С",            "\u0421"),
                        "Т",            "\u0422"),
                        "У",            "\u0423"),
                        "Ф",            "\u0424"),
                        "Х",            "\u0425"),
                        "Ц",            "\u0426"),
                        "Ч",            "\u0427"),
                        "Ш",            "\u0428"),
                        "Щ",            "\u0429"),
                        "Ъ",            "\u042a"),
                        "Ы",            "\u042b"),
                        "Ь",            "\u042c"),
                        "Э",            "\u042d"),
                        "Ю",            "\u042e"),
                        "Я",            "\u042f");
						
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						"а",            "\u0430"),
						"б",            "\u0431"),
						"в",            "\u0432"),
						"г",            "\u0433"),
						"д",            "\u0434"),
						"е",            "\u0435"),
						"ж",            "\u0436"),
						"з",            "\u0437"),
						"и",            "\u0438"),
						"й",            "\u0439"),
						"к",            "\u043a"),
						"л",            "\u043b"),
						"м",            "\u043c"),
						"н",            "\u043d"),
						"о",            "\u043e"),
						"п",            "\u043f"),
						"р",            "\u0440"),
						"с",            "\u0441"),
						"т",            "\u0442"),
						"у",            "\u0443"),
						"ф",            "\u0444"),
						"х",            "\u0445"),
						"ц",            "\u0446"),
						"ч",            "\u0447"),
						"ш",            "\u0448"),
						"щ",            "\u0449"),
						"ъ",            "\u044a"),
						"ы",            "\u044b"),
						"ь",            "\u044c"),
						"э",            "\u044d"),
						"ю",            "\u044e"),
						"я",            "\u044f");
						
		Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат, 
						"’",            "\u2019"),
						"Ґ",            "\u0490"),
						"Ђ",            "\u0402"),
						"Ѓ",            "\u0403"),
						"Ѐ",            "\u0400"),
						"Ё",            "\u0401"),
						"Є",            "\u0404"),
						"Ѕ",            "\u0405"),
						"Ѝ",            "\u040d"),
						"І",            "\u0406"),
						"Ї",            "\u0407"),
						"Ј",            "\u0408"),
						"Љ",            "\u0409"),
						"Њ",            "\u040a"),
						"Ћ",            "\u040b"),
						"Ќ",            "\u040c"),
						"Ў",            "\u040e"),
						"Џ",            "\u040f"),
						"ґ",            "\u0491"),
						"ђ",            "\u0452"),
						"ѓ",            "\u0453"),
						"ѐ",            "\u0450"),
						"ё",            "\u0451"),
						"є",            "\u0454"),
						"ѕ",            "\u0455"),
						"ѝ",            "\u045d"),
						"і",            "\u0456"),
						"ї",            "\u0457"),
						"ј",            "\u0458"),
						"љ",            "\u0459"),
						"њ",            "\u045a"),
						"ћ",            "\u045b"),
						"ќ",            "\u045c"),
						"ў",            "\u045e"),
						"џ",            "\u045f");						
						
	КонецЕсли;
	
	// Кавычки.
	Возврат """" + Результат + """";
	
КонецФункции // jsonЗаписатьСтроку()

Функция jsonЗаписатьСсылку(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Перечисление, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
#Если ВебКлиент Или ТонкийКлиент Тогда
#Иначе
	
	// Идентификатор.
	Если Стандарт Тогда 
		Если Перечисление Тогда Идентификатор = Лев(Прав(ЗначениеВСтрокуВнутр(Значение), 33), 32); Идентификатор = Прав(Идентификатор, 8) + "-" + Сред(Идентификатор, 21, 4) + "-" + Сред(Идентификатор, 17, 4) + "-" + Лев(Идентификатор, 4) + "-" + Сред(Идентификатор, 5, 12); Иначе Идентификатор = XMLСтрока(Значение); КонецЕсли;
	Иначе 
		Идентификатор = ЗначениеВСтрокуВнутр(Значение); Идентификатор = "¦ref¦" + СтрЗаменить(СтрЗаменить(Сред(Идентификатор, 6, СтрДлина(Идентификатор) - 6), ":", "×"), ",", "÷") + "¦";
	КонецЕсли;
	
	// Включая представление ссылки.
	Если ПредставленияСсылок Тогда Возврат jsonЗаписать(Новый Структура("Ссылка,Представление", Идентификатор, Строка(Значение)), Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы); КонецЕсли;
	
	// Ссылка.
	Возврат """" + Идентификатор + """";
	
#КонецЕсли
КонецФункции // jsonЗаписатьСсылку()


// ─────────────────────────────────────────────────────────────────────────────
//  ЛОКАЛИЗАЦИЯ

Функция СформироватьСтрокуПоШаблону(Строка, Параметры)
	
	Результат = Строка;
		
	Для Каждого Параметр Из Параметры Цикл
		Результат = СтрЗаменить(Результат, "[" + Параметр.Ключ + "]", Строка(Параметр.Значение));
	КонецЦикла;

	Возврат Результат;
	
КонецФункции // СформироватьСтрокуПоШаблону()


Функция ИсключениеПустойПакетДанных()
	
	Возврат НСтр("ru = 'JSON: Пустой пакет данных.'; uk = 'JSON: Порожній пакет даних.'");

КонецФункции // ИсключениеНеожиданноеОкончаниеСтроки()

Функция ИсключениеНекорректныйПакетДанных(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный пакет данных в позиции [Индекс].'; uk = 'JSON: Некоректний пакет даних у позиції [Индекс].'"),
		Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйПакетДанных()

Функция ИсключениеНеожиданноеОкончаниеПакетаДанных()
	
	Возврат НСтр("ru = 'JSON: Неожиданное окончание пакета данных.'; uk = 'JSON: Несподіване закінчення пакета даних.'");

КонецФункции // ИсключениеНеожиданноеОкончаниеПакетаДанных()

Функция ИсключениеНеожиданноеОкончаниеМассива(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Неожиданное окончание массива в позиции [Индекс].'; uk = 'JSON: Несподіване закінчення масиву у позиції [Индекс].'"),
		Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНеожиданноеОкончаниеМассива()

Функция ИсключениеНеожиданноеОкончаниеОбъетка(Индекс)

	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Неожиданное окончание объекта в позиции [Индекс].'; uk = 'JSON: Несподіване закінчення об''єкту у позиції [Индекс].'"),
	   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНеожиданноеОкончаниеОбъетка()

Функция ИсключениеНекорректныйТипNull(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный тип Null в позиции [Индекс].'; uk = 'JSON: Некоректний тип Null у позиції [Индекс].'"),
	   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйТипNull()

Функция ИсключениеНекорректныйТипБулево(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный тип Булево в позиции [Индекс].'; uk = 'JSON: Некоректний тип Булево у позиції [Индекс].'"),
	   Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйТипБулево()

Функция ИсключениеНекорректныйТипНеопределено(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный тип Неопределено в позиции [Индекс].'; uk = 'JSON: Некоректний тип Невизначено у позиції [Индекс].'"),
		Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйТипНеопределено()

Функция ИсключениеНекорректныйФорматСтроки(Индекс)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный формат строки в позиции [Индекс].'; uk = 'JSON: Некоректний формат рядка у позиції [Индекс].'"),
		Новый Структура("Индекс", Индекс));

КонецФункции // ИсключениеНекорректныйФорматСтроки()

Функция ИсключениеНекорректныйФорматДаты(Индекс, Значение)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный формат даты [Значение] в позиции [Индекс].'; uk = 'JSON: Некоректний формат дати [Значение] у позиції [Индекс].'"),
		Новый Структура("Индекс", Индекс, Символ(034) + Значение + Символ(034)));

КонецФункции // ИсключениеНекорректныйФорматДаты()

Функция ИсключениеНекорректныйФорматЧисла(Индекс, Значение)
	
	Если ПустаяСтрока(Значение) Тогда
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Неверный формат данных в позиции [Индекс].'; uk = 'JSON: Невірний формат даних у позиції [Индекс].'"),
			Новый Структура("Индекс", Индекс));

	Иначе
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Некорректный формат числа [Значение] в позиции [Индекс].'; uk = 'JSON: Некоректний формат числа [Значение] у позиції [Индекс].'"),
			Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));
					   
	КонецЕсли;
					   
КонецФункции // ИсключениеНекорректныйФорматЧисла()

Функция ИсключениеНедопустимыйСимвол(Индекс, Символ)
	
	Если (Символ = Неопределено) Тогда
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый символ в позиции [Индекс].'; uk = 'JSON: Неприпустимий символ в позиції [Индекс].'"),
			Новый Структура("Индекс", Индекс));

	Иначе
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый символ в позиции [Индекс], ожидается [Символ].'; uk = 'JSON: Неприпустимий символ в позиції [Индекс], очікується [Символ].'"),
			Новый Структура("Индекс,Символ", Индекс, Символ(034) + Символ + Символ(034)));

	КонецЕсли;
				   
КонецФункции // ИсключениеНедопустимыйСимвол()

Функция ИсключениеНеопознанныйТип(Индекс, Тип)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый тип [Тип] в позиции [Индекс].'; uk = 'JSON: Неприпустимий тип [Тип] у позиції [Индекс].'"),
		Новый Структура("Индекс,Тип", Индекс, Символ(034) + Тип + Символ(034)));

КонецФункции // ИсключениеНеопознанныйТип()

Функция ИсключениеНевозможноПреобразоватьЗначение(Индекс, Значение)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Невозможно преобразовать значение [Значение] в позиции [Индекс].'; uk = 'JSON: Неможливо перетворити значення [Значение] у позиції [Индекс].'"),
		Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));

КонецФункции // ИсключениеНевозможноПреобразоватьЗначение()

Функция ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте(Индекс, Значение)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Невозможно на клиенте преобразовать значение [Значение] в позиции [Индекс].'; uk = 'JSON: Неможливо на клієнті перетворити значення [Значение] у позиції [Индекс].'"),
		Новый Структура("Индекс,Значение", Индекс, Символ(034) + Значение + Символ(034)));

КонецФункции // ИсключениеНевозможноПреобразоватьЗначениеНаКлиенте()


Функция ИсключениеНекорректныйПараметр(Параметр)
	
	Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимое значение параметра [Параметр].'; uk = 'JSON: Неприпустиме значення параметра [Параметр].'"),
		Новый Структура("Параметр", Символ(034) + Параметр + Символ(034)));

КонецФункции // ИсключениеНекорректныйПараметр()


Функция ИсключениеНедопустимыйТипКлюча(Индекс, Значение)
	
	Если (Индекс = Неопределено) Тогда
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый тип значения ключа [Тип].'; uk = 'JSON: Неприпустимий тип значення ключа [Тип].'"),
			Новый Структура("Тип", ТипЗнч(Значение)));

	Иначе
		
		Возврат СформироватьСтрокуПоШаблону(НСтр("ru = 'JSON: Недопустимый тип значения ключа [Тип] в позиции [Индекс].'; uk = 'JSON: Неприпустимий тип значення ключа [Тип] в позиції [Индекс].'"),
			Новый Структура("Индекс,Тип", Индекс, Символ(034) + ТипЗнч(Значение) + Символ(034)));

	КонецЕсли;

КонецФункции // ИсключениеНедопустимыйТипКлюча()

Функция ИсключениеНевозможноВыполнитьЗапрос(Описание)
	
	Позиция = Найти(Описание, "}: "); Если Позиция Тогда Позиция = Позиция + 3; Иначе Позиция = 1; КонецЕсли;
	Длина = Найти(Описание, Символы.ПС); Если Длина Тогда Длина = Длина - Позиция; Иначе Длина = СтрДлина(Описание); КонецЕсли;
	Возврат НСтр("ru = 'JSON: Невозможно выполнить запрос. '; uk = 'JSON: Неможливо виконати запит. '") + Сред(Описание, Позиция, Длина) + ".";

КонецФункции // ИсключениеНевозможноВыполнитьЗапрос()






///////////////////////////////////////////////////////////Carbonsoft
Процедура ПриОткрытии()

	тСчетаДляВыгрузки = Новый СписокЗначений;
	тСчетаДляВыгрузки.Добавить(ПланыСчетов.Хозрасчетный.РасчетыСПокупателями);
	тСчетаДляВыгрузки.Добавить(ПланыСчетов.Хозрасчетный.РасчетыПоАвансамПолученным);

	СчетРасчетов	= ПланыСчетов.Хозрасчетный.РасчетыСПокупателями;
	СчетАвансов		= ПланыСчетов.Хозрасчетный.РасчетыПоАвансамПолученным;
	
	СтавкаНДС		= Перечисления.СтавкиНДС.НДС18;
	мВалютаРегламентированногоУчета	= Константы.ВалютаРегламентированногоУчета.Получить();
	
//АдресСервера		= "https://10.0.0.1:1443";
//АдресСервера		= "https://asrdoc.ideco-software.ru:1443";
	//ИдГруппы			= 1;
	//АдресСервера		= "http://10.90.170.55:8082";
	//ИмяПользователя		= "pkvr33ow";
	//ПарольПользователя	= "servicemode";
	
	тСинхронизации		= Новый ТаблицаЗначений;
	тСинхронизации.Колонки.Добавить("code_asr");
	тСинхронизации.Колонки.Добавить("code_1c");
	КолЗапСинхр			= 40;
	
КонецПроцедуры

Процедура ВыбПериодНажатие(Элемент)
	НастройкаПериода = Новый НастройкаПериода;
	НастройкаПериода.УстановитьПериод(НачДата, ?(КонДата='0001-01-01', КонДата, КонецДня(КонДата)));
	НастройкаПериода.РедактироватьКакИнтервал = Истина;
	НастройкаПериода.РедактироватьКакПериод = Истина;
	НастройкаПериода.ВариантНастройки = ВариантНастройкиПериода.Период;
	Если НастройкаПериода.Редактировать() Тогда
		НачДата = НастройкаПериода.ПолучитьДатуНачала();
		КонДата = НастройкаПериода.ПолучитьДатуОкончания();
	КонецЕсли;
КонецПроцедуры

Процедура wget_ПрочитатьЗапрос(ИмяФайла)
	Текст		= Новый ТекстовыйДокумент;
	Текст.ДобавитьСтроку(WinHttpRequest.ResponseText);
	Текст.Записать(ИмяФайла);
КонецПроцедуры

Процедура wget_ОтправитьЗапрос(URL)

	Перем ПерСтрока;
	
	ResolveTimeout	= 60000;
	ConnectTimeout	= 60000;
	SendTimeout		= 60000;
	ReceiveTimeout	= 60000;
//	URL				= "";
	Пользователь	= "";
	Пароль			= "";
	Метод			= "GET";

	WinHttpRequest = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");
	WinHttpRequest.SetTimeouts(ResolveTimeout, ConnectTimeout, SendTimeout, ReceiveTimeout);
	WinHttpRequest.Open(Метод, СокрЛП(URL), 0);
	
	WinHttpRequest.Send(); 
	
КонецПроцедуры
	
Функция ПолучитьКоличествоЗаписей(xml_file,счСтрок,ТегНачала,ТегКонца,ТегОбьекта)
	Стр = "";
	Количество=0;
	НомерС=счСтрок;
	//Пока Найти(Стр,ТегНачала)=0 и Найти(Стр,ТегКонца)=0 Цикл
	//	Стр = СокрЛП(xml_file.ПолучитьСтроку(НомерС));
	//	НомерС	= НомерС + 1;
	//КонецЦикла;
    Пока Найти(Стр,ТегКонца)=0 Цикл
		Стр = СокрЛП(xml_file.ПолучитьСтроку(НомерС));
		НомерС	= НомерС + 1;
		Если Найти(Стр,ТегОбьекта)>0 Тогда
			Количество=Количество+1;
		КонецЕсли
	КонецЦикла;
	Возврат Количество;
КонецФункции

//***********************************************************************************************************
Функция xml_ПрочитатьЗаголовок(xml_file,счСтрок)

	Стр = "";
	Пока Найти(Стр,"<result>")=0 Цикл
//		Стр = СокрЛП(xml_file.ReadLine());
		Стр = СокрЛП(xml_file.ПолучитьСтроку(счСтрок));
		счСтрок	= счСтрок + 1;
	КонецЦикла;
	
//	Стр = "";
//	Пока Найти(Стр,"<errors>")=0 Цикл
////		Стр = СокрЛП(xml_file.ReadLine());
//		Стр = СокрЛП(xml_file.ПолучитьСтроку(счСтрок));
//		счСтрок	= счСтрок + 1;
//	КонецЦикла;
//	ЕстьОшибка = СтрЗаменить(СтрЗаменить(Стр,"<errors>",""),"</errors>","");
//	
//	Если Число(ЕстьОшибка) > 0 Тогда
//		Сообщить("Ошибка в файле загрузки");
//		Для Сч = 1 По Число(ЕстьОшибка) Цикл
//			Стр = "";  
//			Пока Найти(Стр,"<error>")=0 Цикл
////				Стр = СокрЛП(xml_file.ReadLine());
//				Стр = СокрЛП(xml_file.ПолучитьСтроку(счСтрок));
//				счСтрок	= счСтрок + 1;
//			КонецЦикла;
//			Сообщить("	Ошибка:" + СтрЗаменить(СтрЗаменить(Стр,"<error>",""),"</error>",""));
//		КонецЦикла;
//	КонецЕсли;
	ЕстьОшибка=0;
	Возврат Число(ЕстьОшибка);

КонецФункции
	
//***********************************************************************************************************
Функция xml_Прочитать(xml_file,счСтрок,ТегНачала,ТегКонца)
	РеквизитыОбъекта = Новый Соответствие;
					  
	Стр = "";
	Пока Найти(Стр,ТегНачала)=0 Цикл
//		Стр = СокрЛП(xml_file.ReadLine());
		Стр = СокрЛП(xml_file.ПолучитьСтроку(счСтрок));
		счСтрок	= счСтрок + 1;
	КонецЦикла;
	Если Стр = "" Тогда
		Возврат РеквизитыОбъекта;
	КонецЕсли;
		
	Стр = СтрЗаменить(СтрЗаменить(Стр,ТегНачала,""),ТегКонца,"");
	Если Найти(Стр,ТегКонца) = 0 Тогда
		ВрСтр 		= СтрЗаменить(СтрЗаменить(Стр,"><",">,<"),"</","<") + ",";
		НомерПоз	= Найти(ВрСтр,",");
		Пока НомерПоз <> 0 Цикл
			ВрРеквизит	= Лев(ВрСтр,НомерПоз-1);
			ВрСтр		= Сред(ВрСтр,НомерПоз+1);
			
			ПозНач	= Найти(ВрРеквизит,"<");
			ПозКон	= Найти(ВрРеквизит,">");
			xml_ИмяТега  = Сред(ВрРеквизит,ПозНач+1,ПозКон-ПозНач-1);
			xml_Значение = СтрЗаменить(ВрРеквизит,"<"+xml_ИмяТега+">","");
			РеквизитыОбъекта.Вставить(xml_ИмяТега,xml_Значение);
//			Сообщить(xml_ИмяТега + " - " + xml_Значение);
			
			НомерПоз	= Найти(ВрСтр,",");
		КонецЦикла;
	КонецЕсли;
	
	Возврат РеквизитыОбъекта;

КонецФункции

//***********************************************************************************************************                               
Процедура ПровестиСинхронизацию(suid,Тип)
	
	Если тСинхронизации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	ИмяФайла_подтв	= КаталогВременныхФайлов() + "\tmp_import_sync.xml";
	счСтрок			= 1;
	
	Если Тип = 1 Тогда
//Синхронизация справочника контрагенты
		params	= "model=Abonents&method1=api_1c_manager.api_1c_sync_abonent"		
	ИначеЕсли Тип = 2 ИЛИ Тип = 3  Тогда
//Синхронизация ПКО
		params = "model=FinanceOperations&method1=api_1c_manager.api_1c_sync_fin_oper"
	КонецЕсли;

	Для Каждого СтрокаТЧ Из тСинхронизации Цикл
		params2 = "";
		Если Тип<>2 И Тип<>3 Тогда 
			params2 = params + "&arg1={"+Символ(34)+"pk"+Символ(34)+":"+Символ(34)+СтрЗаменить(СтрокаТЧ.code_asr,Символы.НПП,"")+Символ(34)+",";
			params2=params2+Символ(34)+"code1c"+Символ(34)+":"+Символ(34)+Формат(СтрокаТЧ.code_1c,"ЧГ=0")+Символ(34)+","+Символ(34)+"sync1c"+Символ(34)+":"+Символ(34)+Формат(1,"ЧГ=0")+Символ(34)+"}";
			data=ОтправитьRestЗапрос(ИмяФайла_подтв,params2);
		Иначе 
		    args=Новый Соответствие;
	 		args["pk"]=СтрЗаменить(СтрокаТЧ.code_asr,Символы.НПП,"");
	 		args["code1c"]=СтрокаТЧ.code_1c;
			params2 = params +"&arg1="+form_params_str(args);
			//params = params + "&method3=save&arg3={}";
			data=ОтправитьRestЗапрос(ИмяФайла_подтв,params2);
		КонецЕсли;
		
	КонецЦикла;
		
	тСинхронизации.Очистить();
	
КонецПроцедуры


//***********************************************************************************************************
Функция form_params_str(params)
	res="";
	/// Для Элемент.Значение убираем непечатаемые пробелы. Титусов
	Для Каждого Элемент из params Цикл 
        res=res+Символ(34)+Элемент.Ключ+Символ(34)+":"+Символ(34)+СтрЗаменить(Строка(Элемент.Значение), Символы.НПП,"")+Символ(34)+","	
	КонецЦикла; 
	res=Лев(res,СтрДлина(res)-1);
	res="{"+res+"}";
	Возврат res
КонецФункции
Функция ПолучитьРеквизиты(suid,abon_id)
	 params			= "model=Abonents&method1=api_1c_manager.api_1c_get_abonent_attr&arg1={"+Символ(34)+"abonent_id"+Символ(34)+":"+Символ(34)+Формат(abon_id,"ЧГ=0")+Символ(34)+"}";
	 ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_recvis.xml";

	 Реквизиты=ОтправитьRestЗапрос(ИмяФайла,params);
	 колич=Реквизиты.Количество();
	 результат=Новый Соответствие;
	 Для сч2=0 по колич-1 цикл
		  результат [Реквизиты[сч2] ["fields"]["attribute"] ]=Реквизиты[сч2] ["fields"] ["attribute_value"];		 
	 КонецЦикла;
	 Возврат результат;

 КонецФункции
Функция ПолучитьУчетныеДанные(suid,abon_id)
	 params			= "model=Abonents&method1=api_1c_manager.api_1c_get_abonent_users&arg1={"+Символ(34)+"abonent_id"+Символ(34)+":"+Символ(34)+Формат(abon_id,"ЧГ=0")+Символ(34)+"}";
	 ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_users.xml";
	 data=ОтправитьRestЗапрос(ИмяФайла,params);
	 Возврат data;

 КонецФункции
Функция ПолучитьСчет(suid,abonent_id)
	 params			= "model=Abonents&method1=api_1c_manager.api_1c_get_account&arg1={"+Символ(34)+"abonent_id"+Символ(34)+":"+Символ(34)+Формат(abonent_id,"ЧГ=0")+Символ(34)+"}";
	 ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_account.xml";
	 data=ОтправитьRestЗапрос(ИмяФайла,params);
	 Возврат data[0];
КонецФункции
Функция ПолучитьКонтрагентов(suid,parent_id,sync1c)
	 params	= "model=Abonents&method1=api_1c_manager.api_1c_get_abonents";
	 args=Новый Соответствие;
	 args["parent_id"]=parent_id;
	 args["sync1c"]=sync1c;
	 params=params+"&arg1="+form_params_str(args);
	 ИмяФайла = КаталогВременныхФайлов() + "\tmp_import_contr.xml";
	 data=ОтправитьRestЗапрос(ИмяФайла,params);
	 Возврат data;
 КонецФункции
Функция ПолучитьКонтрагентаПоКоду(suid,code1c)
	 URL			= "model=Abonents&method1=objects.filter&arg1={"+Символ(34)+"code1c"+Символ(34)+":"+Символ(34)+Формат(code1c,"ЧГ=0")+Символ(34)+"}";//+"&hash_key="+Строка(suid)+"&format=json";
	 ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_contr.xml";
	 data= ОтправитьRestЗапрос(ИмяФайла,URL);
	 Контрагент=data.Получить("result").Получить("result");
	 Возврат Контрагент;
 КонецФункции
Функция ПолучитьОперациюПоКоду(suid,code1c)
	 params			= "model=FinanceOperations&method1=objects.filter&arg1={"+Символ(34)+"code1c"+Символ(34)+":"+Символ(34)+Формат(code1c,"ЧГ=0")+Символ(34)+"}";//+"&hash_key="+Строка(suid)+"&format=json";
	 params = params+"&fields1=["+Символ(34)+"op_id"+Символ(34);
	 params = params+"]";
	 ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_oper.xml";
	 data= ОтправитьRestЗапрос(ИмяФайла,params);
	 Контрагент=data.Получить("result").Получить("result");
	 Возврат Контрагент;
КонецФункции
 
Функция ОтправитьRestЗапрос(ИмяФайла,params)
	URL=АдресСервера+"/system_api/?"+params+"&psw="+Строка(ИмяПользователя)+"&format=json&context=api_1c";
	wget_ОтправитьЗапрос(URL);
	wget_ПрочитатьЗапрос(ИмяФайла);
	Файлjson=Новый ТекстовыйДокумент;
	Файлjson.Прочитать(ИмяФайла);
	jsontext=Файлjson.ПолучитьТекст();
	Попытка
		data=ПрочитатьJSON(jsontext);
	Исключение
		Сообщить("Не опознанный результат:");
		Сообщить(jsontext);
		
	КонецПопытки;
	Если ТипЗнч(data)=Тип("Соответствие") И data.Получить("error_text")<>Неопределено Тогда
		msg="Неудалось выполнить запрос: "+data.Получить("error_text");
		Сообщить(msg);
		ВызватьИсключение msg;
	КонецЕсли;
	Если ТипЗнч(data)=Тип("Массив") И data.Количество()>0 И data[0].Получить("error_text")<>Неопределено Тогда
		msg="Неудалось выполнить запрос: "+data[0].Получить("error_text");
		Сообщить(msg);
		ВызватьИсключение msg;
	КонецЕсли;
	
	//dsfs
	Возврат data
КонецФункции

Функция ПолучитьОперации(suid,abonent_id,op_type,start_date,end_date)
	 params			= "model=FinanceOperations&method1=api_1c_manager.api_1c_get_fin_opers";
	 args=Новый Соответствие;
	 args["abonent_id"]=abonent_id;
	 args["op_type"]=op_type;
	 args["start_date"]=start_date;
	 args["end_date"]=end_date;
     params=params+"&arg1="+form_params_str(args);
	 ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_fin.xml";
	 data=ОтправитьRestЗапрос(ИмяФайла,params);
	 Возврат data;

 КонецФункции
 Функция ОтправитьФинОперацию(suid,params)
	 	ИмяФайла	= КаталогВременныхФайлов() + "\tmp_export_finoper_add.xml";
		URL	= "model=FinanceOperations&method1=api_1c_manager.api_1c_sync_fin_oper";
		Инфо = Новый СистемнаяИнформация;
		//Если Лев(Инфо.ВерсияПриложения,3)="8.2" Тогда
		formed_params = URLEncode(form_params_str(params));
		//Иначе
			//formed_params = КодироватьСтроку(form_params_str(params), СпособКодированияСтроки.КодировкаURL);
		//КонецЕсли;
		URL = URL+"&arg1="+formed_params;
		ОтправитьRestЗапрос(ИмяФайла,URL);

КонецФункции

Процедура ПрочитатьКонтрагентов(suid)
	счСтрок			= 1;
	parent_id=СтрЗаменить(Строка(ИдГруппы), Символы.НПП,"");
	массивОбьектов=ПолучитьКонтрагентов(suid,parent_id,0);	
	Стр = "";
	КоличествоЗаписей=массивОбьектов.Количество();
	Для Сч = 0 По КоличествоЗаписей-1 Цикл
		 РеквизитыОбъекта = массивОбьектов[Сч].Получить("fields");		 
		 abon_id=массивОбьектов[Сч].Получить("pk");      
		 account_id=РеквизитыОбъекта.Получить("account");
		 Реквизиты=ПолучитьРеквизиты(suid,abon_id);
		 Учетки=ПолучитьУчетныеДанные(suid,abon_id);
		 Счет=ПолучитьСчет(suid,abon_id);
		 login="";
		 ip="";
		 КоличУч=Учетки.Количество();
		 Для сч1=0 по КоличУч-1 цикл
			  login=login+Учетки[сч1]["fields"].Получить("login")+";";
			  ip=ip+Учетки[сч1]["fields"].Получить("ip")+";";
		  КонецЦикла;		  
		 	user_id		= abon_id;
		 	name		= РеквизитыОбъекта.Получить("name");
		 	full_name	= name;
		  inn			= Реквизиты.Получить(4);
		  kpp			= Реквизиты.Получить(5);
		 	code1c		= РеквизитыОбъекта.Получить("code1c");
		 	email		= РеквизитыОбъекта.Получить("email");
		 	ostatok		= Счет["fields"].Получить("ostatok");
		 	debit		= Счет["fields"].Получить("debit");
		 	credit		= Счет["fields"].Получить("credit");
		  address_u	= Реквизиты.Получить(3);
		  address_f	= Реквизиты.Получить(3);
		  is_phys		= РеквизитыОбъекта.Получить("company");
		 	tel			= РеквизитыОбъекта.Получить("sms");
		 	contract_number	= РеквизитыОбъекта.Получить("contract_number");
		 	
			НайденныйКонтрагент	= Справочники.Контрагенты.ПустаяСсылка();
			
			Если (ЗначениеЗаполнено(code1c)) И НЕ ЗначениеЗаполнено(НайденныйКонтрагент) Тогда
				НайденныйКонтрагент	= Справочники.Контрагенты.НайтиПоКоду(code1c);
			КонецЕсли;
			
			Если (ЗначениеЗаполнено(inn)) И НЕ ЗначениеЗаполнено(НайденныйКонтрагент) Тогда
				НайденныйКонтрагент	= Справочники.Контрагенты.НайтиПоРеквизиту("ИНН",inn);
			КонецЕсли;	
				
			Если ЗначениеЗаполнено(НайденныйКонтрагент) Тогда
				Контрагент	= НайденныйКонтрагент.ПолучитьОбъект();
			Иначе
				Контрагент	= Справочники.Контрагенты.СоздатьЭлемент();
			КонецЕсли;
			
			СтрокаКомментария	= "";
			СтрокаКомментария	= СтрокаКомментария + ?(login = "NULL",			"","login = " + Строка(login)+";");
			СтрокаКомментария	= СтрокаКомментария + ?(user_id = "NULL",		"","user_id = " + Строка(user_id)+";");
			СтрокаКомментария	= СтрокаКомментария + ?(ip = "NULL",			"","ip = " + Строка(ip)+";");
			
//			Контрагент.Наименование 	= name + " (" + user_id + ")";
			Контрагент.Наименование 	= name;
//			Контрагент.ОсновнойДоговорКонтрагента
			Контрагент.Комментарий		= СтрокаКомментария;
//			Контрагент.ГоловнойКонтрагент
			Инфо = Новый СистемнаяИнформация;
			Если Лев(Константы.НомерВерсииКонфигурации.Получить(),3)="2.0" Тогда
				Контрагент.ЮрФизЛицо		= ?(is_phys = 0, Перечисления.ЮрФизЛицо.ФизЛицо, Перечисления.ЮрФизЛицо.ЮрЛицо);
			Иначе
				Контрагент.ЮридическоеФизическоеЛицо		= ?(is_phys = 0, Перечисления.ЮридическоеФизическоеЛицо.ФизическоеЛицо, Перечисления.ЮридическоеФизическоеЛицо.ЮридическоеЛицо);
			КонецЕсли;
			Контрагент.ИНН				= СтрЗаменить(inn,"NULL","");
//			Контрагент.КодПоОКПО
			Контрагент.КПП				= СтрЗаменить(kpp,"NULL","");
			Контрагент.НаименованиеПолное	= full_name;
//			Контрагент.ОсновнойБанковскийСчет
//			Контрагент.ДокументУдостоверяющийЛичность
//			Контрагент.ОсновноеКонтактноеЛицо
			Попытка
				Контрагент.Записать();
			Исключение
				Сообщить("Не удалось создать контрагента: код(" + Строка(Контрагент.Код)+"),ИНН("+Контрагент.ИНН+"),Наименование("+Контрагент.Наименование+")");
				Если Не ЗначениеЗаполнено(Контрагент.Код) Тогда
					Сообщить("Пытаемся создать с кодом из биллинга");
					Контрагент.Код="B"+СтрЗаменить(abon_id,Символы.НПП,"");
					Контрагент.Записать();
				Иначе
					Продолжить;
				КонецЕсли;
			КонецПопытки;
			Контрагент.ГоловнойКонтрагент	= Контрагент.Ссылка;
			Контрагент.Записать();

			НайденныйДоговор	= Справочники.ДоговорыКонтрагентов.НайтиПоНаименованию("С покупателем",,,Контрагент.Ссылка);
			
			Если ЗначениеЗаполнено(НайденныйДоговор) Тогда
				ДоговорКонтрагента	= НайденныйДоговор.ПолучитьОбъект();
			Иначе
				ДоговорКонтрагента	= Справочники.ДоговорыКонтрагентов.СоздатьЭлемент();
			КонецЕсли;
			
			ДоговорКонтрагента.Наименование		= "С покупателем";
			ДоговорКонтрагента.Владелец			= Контрагент.Ссылка;
			ДоговорКонтрагента.ВалютаВзаиморасчетов	= мВалютаРегламентированногоУчета;
//			ДоговорКонтрагента.Комментарий
			ДоговорКонтрагента.Организация		= Организация;
//			ДоговорКонтрагента.ПроцентКомиссионногоВознаграждения
//			ДоговорКонтрагента.СпособРасчетаКомиссионногоВознаграждения
//			ДоговорКонтрагента.ТипЦен
			ДоговорКонтрагента.ВидДоговора		= Перечисления.ВидыДоговоровКонтрагентов.СПокупателем;
			ДоговорКонтрагента.УчетАгентскогоНДС		= Ложь;
//			ДоговорКонтрагента.ВидАгентскогоДоговора
			ДоговорКонтрагента.РасчетыВУсловныхЕдиницах	= Ложь;
			ДоговорКонтрагента.РеализацияНаЭкспорт		= Ложь;
//			ДоговорКонтрагента.ВидВзаиморасчетов
//			ДоговорКонтрагента.Дата
			ДоговорКонтрагента.Номер					= contract_number;
//			ДоговорКонтрагента.СрокДействия
//			ДоговорКонтрагента.УстановленСрокОплаты
//			ДоговорКонтрагента.СрокОплаты
//			ДоговорКонтрагента.НаименованиеДляСчетаФактурыНаАванс
			ДоговорКонтрагента.ПорядокРегистрацииСчетовФактурНаАвансПоДоговору	= Перечисления.ПорядокРегистрацииСчетовФактурНаАванс.НаВсеАвансы;
//			ДоговорКонтрагента.НалоговыйАгентПоОплате
//			ДоговорКонтрагента.ИспользуетсяПриОбменеДанными
			ДоговорКонтрагента.Записать();
			Если Лев(Константы.НомерВерсииКонфигурации.Получить(),3)="2.0" Тогда
				КонтактнаяИнформация=РегистрыСведений.КонтактнаяИнформация.СоздатьНаборЗаписей();
			Иначе
				КонтактнаяИнформация=Контрагент.КонтактнаяИнформация;
			КонецЕсли;
			//КонтактнаяИнформация.Отбор.Объект.Значение		= Контрагент.Ссылка;
			//КонтактнаяИнформация.Отбор.Объект.ВидСравнения	= ВидСравнения.Равно;
			//КонтактнаяИнформация.Отбор.Объект.Использование	= Истина;
			
			НоваяЗапись				= КонтактнаяИнформация.Добавить();
			Если Лев(Константы.НомерВерсииКонфигурации.Получить(),3)="2.0" Тогда
				НоваяЗапись.Активность	= Истина;
				НоваяЗапись.Объект		= Контрагент.Ссылка;
			КонецЕсли;
			НоваяЗапись.Тип			= Перечисления.ТипыКонтактнойИнформации.Адрес;
			НоваяЗапись.Вид			= Справочники.ВидыКонтактнойИнформации.ЮрАдресКонтрагента;
			НоваяЗапись.Представление	= СтрЗаменить(address_u,"NULL","");;
	
			НоваяЗапись				= КонтактнаяИнформация.Добавить();
			Если Лев(Константы.НомерВерсииКонфигурации.Получить(),3)="2.0" Тогда
				НоваяЗапись.Активность	= Истина;
				НоваяЗапись.Объект		= Контрагент.Ссылка;
			КонецЕсли;
			НоваяЗапись.Тип			= Перечисления.ТипыКонтактнойИнформации.Адрес;
			НоваяЗапись.Вид			= Справочники.ВидыКонтактнойИнформации.ФактАдресКонтрагента;
			НоваяЗапись.Представление	= СтрЗаменить(address_f,"NULL","");;
			
			НоваяЗапись				= КонтактнаяИнформация.Добавить();
			Если Лев(Константы.НомерВерсииКонфигурации.Получить(),3)="2.0" Тогда
				НоваяЗапись.Активность	= Истина;
				НоваяЗапись.Объект		= Контрагент.Ссылка;
			КонецЕсли;
			НоваяЗапись.Тип			= Перечисления.ТипыКонтактнойИнформации.Телефон;
			НоваяЗапись.Вид			= Справочники.ВидыКонтактнойИнформации.ТелефонКонтрагента;
			НоваяЗапись.Представление	= СтрЗаменить(tel,"NULL","");;
			
			НоваяЗапись				= КонтактнаяИнформация.Добавить();
			Если Лев(Константы.НомерВерсииКонфигурации.Получить(),3)="2.0" Тогда
				НоваяЗапись.Активность	= Истина;
				НоваяЗапись.Объект		= Контрагент.Ссылка;
			КонецЕсли;
			НоваяЗапись.Тип			= Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты;
			НоваяЗапись.Вид			= Справочники.ВидыКонтактнойИнформации.EmailОрганизации;
			НоваяЗапись.Представление	= СтрЗаменить(email,"NULL","");;
			Если Лев(Инфо.ВерсияПриложения,3)="8.2" Тогда
				КонтактнаяИнформация.Записать();
			КонецЕсли;
			Контрагент.Записать();
			
			НоваяСтрока		= тСинхронизации.Добавить();
			НоваяСтрока.code_asr	= Строка(user_id);
			НоваяСтрока.code_1c		= Строка(Контрагент.Код);

			Если тСинхронизации.Количество() = КолЗапСинхр Тогда
				ПровестиСинхронизацию(suid,1);
			КонецЕсли;
			Сообщить("Создан контрагент с кодом: " + Строка(Контрагент.Код));
		 	
		 //КонецЕсли;
	КонецЦикла;
	ПровестиСинхронизацию(suid,1);
КонецПроцедуры
Процедура ПрочитатьПКО(suid)
	//URL			= АдресСервера+"/api.php?cmd=select&proc=API_FINOPER_LIST&arg1="+Строка(suid)+"&arg2="+Формат(ИдГруппы,"ЧГ=0")+"&arg3=2";
//	Сообщить(URL);

	//ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_finoper.xml";
	счСтрок			= 1;
//+SHDE
//	ИмяФайла_подтв	= КаталогВременныхФайлов() + "\tmp_import_finoper_sync.xml";
//-SHDE
	
	//xml_ОтправитьЗапрос(URL);
	//xml_ПрочитатьЗапрос(ИмяФайла);
	//
	//ФайлЗагрузки		= xml_ОткрытьФайл(ИмяФайла,счСтрок);
	СчитыватьДанные		= 1;
	КоличествоЗаписей 	= 0;

	//ЕстьОшибка	= xml_ПрочитатьЗаголовок(ФайлЗагрузки,счСтрок);	
	//Если ЕстьОшибка > 0 Тогда
	//	Возврат;
	//КонецЕсли;
	
	Стр = "";
//	Пока Найти(Стр,"<rows>")=0 Цикл
////		Стр = СокрЛП(ФайлЗагрузки.ReadLine());
//		Стр = СокрЛП(ФайлЗагрузки.ПолучитьСтроку(счСтрок));
//		счСтрок	= счСтрок + 1;
//	КонецЦикла;
	контрагенты=ПолучитьКонтрагентов(suid,ИдГруппы,1);
	КоличествоЗаписей = контрагенты.Количество();//Число(СтрЗаменить(СтрЗаменить(Стр,"<rows>",""),"</rows>",""));

	Для Сч = 0 По КоличествоЗаписей-1 Цикл
		 Операции=ПолучитьОперации(suid,контрагенты[сч]["pk"],2,НачДата,КонДата);
		 колОпер=Операции.Количество();
		 Для сч2=0 по колОпер-1 цикл
		    РеквизитыОбъекта = Операции[сч2];//xml_Прочитать(ФайлЗагрузки,счСтрок,"<row>","</row>");
		 //Если РеквизитыОбъекта <> 0 Тогда
			op_id		= Операции[сч2]["op_id"];
			op_type		= РеквизитыОбъекта.Получить("op_type_id");
			op_date		= РеквизитыОбъекта.Получить("op_date");
			op_summa	= РеквизитыОбъекта.Получить("op_summa");
			op_card_id	= РеквизитыОбъекта.Получить("op_card_id");
			pr_number	= РеквизитыОбъекта.Получить("number");
			balance_buh	= РеквизитыОбъекта.Получить("balance_buh");
			descr		= РеквизитыОбъекта.Получить("descr");
			end_user			= 1;//РеквизитыОбъекта.Получить("end_user");
			operator_pay_id		= РеквизитыОбъекта.Получить("operator_pay_id");
			operator_name		= РеквизитыОбъекта.Получить("operator_name");
			operator_result		= РеквизитыОбъекта.Получить("operator_result");
			operator_pay_id_str	= РеквизитыОбъекта.Получить("operator_pay_id_str");
			code1c				= РеквизитыОбъекта.Получить("code1c");
			users_code1c		= контрагенты[сч]["fields"].Получить("code1c");
			users_identify		= контрагенты[сч]["fields"].Получить("name");
			
			Если НЕ ЗначениеЗаполнено(code1c) Тогда
				РасчетнаяСтавкаНДС	= Число(Лев(СтавкаНДС,2)/100);//УчетНДС.ПолучитьСтавкуНДС(СтавкаНДС)/100;
				СтрокаКомментария	= "";
				СтрокаКомментария	= СтрокаКомментария + ?(op_card_id = "NULL",		"","op_card_id = " + Строка(op_card_id)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(pr_number = "NULL",			"","namber = " + Строка(pr_number)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(balance_buh = "NULL",		"","balance_buh = " + Строка(balance_buh)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_pay_id = "NULL",	"","operator_pay_id = " + Строка(operator_pay_id)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_name = "NULL",		"","operator_name = " + Строка(operator_name)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_result = "NULL",	"","operator_result = " + Строка(operator_result)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_pay_id_str = "NULL","","operator_pay_id_str = " + Строка(operator_pay_id_str)+";");

				Контрагент			= Справочники.Контрагенты.НайтиПоКоду(users_code1c);
				Если ЗначениеЗаполнено(Контрагент) Тогда
			
					Договор			= Справочники.ДоговорыКонтрагентов.НайтиПоНаименованию("С покупателем",,,Контрагент);
					Если Не ЗначениеЗаполнено(Договор) Тогда
						ДоговорКонтрагента		= Справочники.ДоговорыКонтрагентов.СоздатьЭлемент();
						ДоговорКонтрагента.Наименование		= "С покупателем";
						ДоговорКонтрагента.Владелец			= Контрагент;
						ДоговорКонтрагента.ВалютаВзаиморасчетов	= мВалютаРегламентированногоУчета;
//						ДоговорКонтрагента.Комментарий
						ДоговорКонтрагента.Организация		= Организация;
//						ДоговорКонтрагента.ПроцентКомиссионногоВознаграждения
//						ДоговорКонтрагента.СпособРасчетаКомиссионногоВознаграждения
//						ДоговорКонтрагента.ТипЦен
						ДоговорКонтрагента.ВидДоговора		= Перечисления.ВидыДоговоровКонтрагентов.СПокупателем;
						ДоговорКонтрагента.УчетАгентскогоНДС		= Ложь;
//						ДоговорКонтрагента.ВидАгентскогоДоговора
						ДоговорКонтрагента.РасчетыВУсловныхЕдиницах	= Ложь;
						ДоговорКонтрагента.РеализацияНаЭкспорт		= Ложь;
//						ДоговорКонтрагента.ВидВзаиморасчетов
//						ДоговорКонтрагента.Дата
//						ДоговорКонтрагента.Номер
//						ДоговорКонтрагента.СрокДействия
//						ДоговорКонтрагента.УстановленСрокОплаты
//						ДоговорКонтрагента.СрокОплаты
//						ДоговорКонтрагента.НаименованиеДляСчетаФактурыНаАванс
						ДоговорКонтрагента.ПорядокРегистрацииСчетовФактурНаАвансПоДоговору	= Перечисления.ПорядокРегистрацииСчетовФактурНаАванс.НаВсеАвансы;
//						ДоговорКонтрагента.НалоговыйАгентПоОплате
//						ДоговорКонтрагента.ИспользуетсяПриОбменеДанными
						ДоговорКонтрагента.Записать();
						Договор	= ДоговорКонтрагента.Ссылка;
					КонецЕсли;
				КонецЕсли;
				
//Заполнение шапки документа ПКО
				ПКО			= Документы.ПриходныйКассовыйОрдер.СоздатьДокумент();
				ПКО.Дата				= Сред(op_date,0,4)+Сред(op_date,6,2)+Сред(op_date,9,2); 
				ПКО.Организация			= Организация;
				ПКО.СчетКасса			= ПланыСчетов.Хозрасчетный.КассаОрганизации;
				ПКО.ВидОперации			= Перечисления.ВидыОперацийПКО.ОплатаПокупателя;
				ПКО.Контрагент			= Контрагент;
				ПКО.ДоговорКонтрагента	= Договор;
				ПКО.ВалютаДокумента		= мВалютаРегламентированногоУчета;
				ПКО.СуммаДокумента		= Число(op_summa);
				ПКО.ПринятоОт			= users_identify;
				ПКО.Основание			= "Оплата за услуги за период " + descr;
//				ПКО.Приложение
//				ПКО.Ответственный
				ПКО.Комментарий			= СтрокаКомментария;
//				ПКО.ДокументОснование
				ПКО.СчетУчетаРасчетовСКонтрагентом	= СчетРасчетов;
//				ПКО.СубконтоКт1
//				ПКО.СубконтоКт2
//				ПКО.СубконтоКт3
				ПКО.СтатьяДвиженияДенежныхСредств	= СтатьяДДС;
				ПКО.СтавкаНДС						= СтавкаНДС;
//				ПКО.Содержание_УСН
//				ПКО.Графа4_УСН
//				ПКО.Графа5_УСН
//				ПКО.Графа6_УСН
//				ПКО.Графа7_УСН
//				ПКО.ДоходыЕНВД_УСН
//				ПКО.РасходыЕНВД_УСН
//				ПКО.НДС_УСН
//				ПКО.РучнаяНастройка_УСН
//				ПКО.ВыручкаСНТТ
//				ПКО.НомерЧекаККМ
				ПКО.РучнаяКорректировка	= Ложь;
//				ПКО.ПодразделениеКт

//Заполнение ТЧ РасшифровкаПлатежа документа ПКО
				НоваяСтрока	= ПКО.РасшифровкаПлатежа.Добавить();
				НоваяСтрока.ДоговорКонтрагента				= Договор;
//				НоваяСтрока.Сделка
				НоваяСтрока.КурсВзаиморасчетов				= 1;
				НоваяСтрока.СуммаПлатежа					= Число(op_summa);
				НоваяСтрока.КратностьВзаиморасчетов			= 1;
				НоваяСтрока.СуммаВзаиморасчетов				= Число(op_summa);
				НоваяСтрока.СтавкаНДС						= СтавкаНДС;
				НоваяСтрока.СуммаНДС						= Число(op_summa)*РасчетнаяСтавкаНДС;
				НоваяСтрока.СтатьяДвиженияДенежныхСредств	= СтатьяДДС;
				НоваяСтрока.СчетУчетаРасчетовСКонтрагентом	= СчетРасчетов;
				НоваяСтрока.СчетУчетаРасчетовПоАвансам		= СчетАвансов;
//				НоваяСтрока.СчетНаОплату
				НоваяСтрока.СпособПогашенияЗадолженности	= Перечисления.СпособыПогашенияЗадолженности.Автоматически;
				ПКО.Записать();
				   
//+SHDE
//				URL = АдресСервера+"/api.php?cmd=select&proc=API_FINOPER_SYNC&arg1="+Строка(suid)+
//						"&arg2="+Строка(op_id)+"&arg3="+Строка("H"+Строка(ДатаГод(ПКО.ДатаДок))+"_"+ПКО.НомерДок);
//				xml_ОтправитьЗапрос(URL);
//+Обработка результата запроса
//				xml_ПрочитатьЗапрос(ИмяФайла_подтв);
//				ФайлПодтв	= xml_ОткрытьФайл(ИмяФайла_подтв);
//				xml_ПрочитатьЗаголовок(ФайлПодтв);
//				xml_Закрыть(ФайлПодтв);
//-Обработка результата запроса

				НоваяСтрока		= тСинхронизации.Добавить();
				НоваяСтрока.code_asr	= Строка(op_id);
				НоваяСтрока.code_1c		= Строка(Формат(Год(ПКО.Дата),"ЧГ=0")+"_"+ПКО.Номер);

				Если тСинхронизации.Количество() = КолЗапСинхр Тогда
					ПровестиСинхронизацию(suid,2);
				КонецЕсли;
//-SHDE
				Сообщить("Создан приходный кассовый ордер с кодом: " + Строка(ПКО.Номер) + " от " + Строка(ПКО.Дата));
			КонецЕсли;
		 	
		//КонецЕсли;
		конеццикла;
	КонецЦикла;
	
//+SHDE
	ПровестиСинхронизацию(suid,2);
//-SHDE

	//xml_Закрыть(ФайлЗагрузки);
КонецПроцедуры
Процедура ПрочитатьАкт(suid,ТипОперации,ДопНаименование = "")
	//URL			= АдресСервера+"/api.php?cmd=select&proc=API_FINOPER_LIST&arg1="+Строка(suid)+"&arg2="+Формат(ИдГруппы,"ЧГ=0")+"&arg3="+Строка(ТипОперации);

	//ИмяФайла		= КаталогВременныхФайлов() + "\tmp_import_finoper.xml";
	счСтрок			= 1;
//+SHDE
//	ИмяФайла_подтв	= КаталогВременныхФайлов() + "\tmp_import_finoper_sync.xml";
//-SHDE
	
	//xml_ОтправитьЗапрос(URL);
	//xml_ПрочитатьЗапрос(ИмяФайла);
	
	//ФайлЗагрузки		= xml_ОткрытьФайл(ИмяФайла,счСтрок);
	СчитыватьДанные		= 1;
	КоличествоЗаписей 	= 0;

	//ЕстьОшибка	= xml_ПрочитатьЗаголовок(ФайлЗагрузки,счСтрок);	
	//Если ЕстьОшибка > 0 Тогда
	//	Возврат;
	//КонецЕсли;
	//
	Стр = "";
//	Пока Найти(Стр,"<rows>")=0 Цикл
////		Стр = СокрЛП(ФайлЗагрузки.ReadLine());
//		Стр = СокрЛП(ФайлЗагрузки.ПолучитьСтроку(счСтрок));
//		счСтрок	= счСтрок + 1;
//	КонецЦикла;
	контрагенты=ПолучитьКонтрагентов(suid,ИдГруппы,1);
	КоличествоЗаписей = контрагенты.Количество();//Число(СтрЗаменить(СтрЗаменить(Стр,"<rows>",""),"</rows>",""));

	Для Сч = 0 По КоличествоЗаписей-1 Цикл
		Операции=ПолучитьОперации(suid,контрагенты[сч]["pk"],ТипОперации,НачДата,КонДата);
		 колОпер=Операции.Количество();
		 Для сч2=0 по колОпер-1 цикл

		 РеквизитыОбъекта = Операции[сч2];//xml_Прочитать(ФайлЗагрузки,счСтрок,"<row>","</row>");
		 //Если РеквизитыОбъекта <> 0 Тогда
			op_id		= Операции[сч2]["op_id"];
			op_type		= РеквизитыОбъекта.Получить("op_type");
			op_date		= РеквизитыОбъекта.Получить("op_date");
			op_summa	= РеквизитыОбъекта.Получить("op_summa");
			op_card_id	= РеквизитыОбъекта.Получить("op_card_id");
			pr_number	= РеквизитыОбъекта.Получить("number");
			balance_buh	= РеквизитыОбъекта.Получить("balance_buh");
			descr		= ДопНаименование + РеквизитыОбъекта.Получить("descr");
			end_user			= 1;//РеквизитыОбъекта.Получить("end_user");
			operator_pay_id		= РеквизитыОбъекта.Получить("operator_pay_id");
			operator_name		= РеквизитыОбъекта.Получить("operator_name");
			operator_result		= РеквизитыОбъекта.Получить("operator_result");
			operator_pay_id_str	= РеквизитыОбъекта.Получить("operator_pay_id_str");
			code1c				= РеквизитыОбъекта.Получить("code1c");
			users_code1c		= контрагенты[сч]["fields"].Получить("code1c");
			users_identify		= контрагенты[сч]["fields"].Получить("name");
			
			Если Не ЗначениеЗаполнено(code1c) Тогда
				РасчетнаяСтавкаНДС	= Число(Лев(СтавкаНДС,2)/100);//УчетНДС.ПолучитьСтавкуНДС(СтавкаНДС)/100;
				СтрокаКомментария	= "";
				СтрокаКомментария	= СтрокаКомментария + ?(op_card_id = "NULL",		"","op_card_id = " + Строка(op_card_id)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(pr_number = "NULL",			"","namber = " + Строка(pr_number)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(balance_buh = "NULL",		"","balance_buh = " + Строка(balance_buh)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_pay_id = "NULL",	"","operator_pay_id = " + Строка(operator_pay_id)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_name = "NULL",		"","operator_name = " + Строка(operator_name)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_result = "NULL",	"","operator_result = " + Строка(operator_result)+";");
				СтрокаКомментария	= СтрокаКомментария + ?(operator_pay_id_str = "NULL","","operator_pay_id_str = " + Строка(operator_pay_id_str)+";");
				
				Контрагент			= Справочники.Контрагенты.НайтиПоКоду(users_code1c);
				Если ЗначениеЗаполнено(Контрагент) Тогда
					
					Договор			= Справочники.ДоговорыКонтрагентов.НайтиПоНаименованию("С покупателем",,,Контрагент);
					Если Не ЗначениеЗаполнено(Договор) Тогда
						ДоговорКонтрагента		= Справочники.ДоговорыКонтрагентов.СоздатьЭлемент();
						ДоговорКонтрагента.Наименование		= "С покупателем";
						ДоговорКонтрагента.Владелец			= Контрагент;
						ДоговорКонтрагента.ВалютаВзаиморасчетов	= мВалютаРегламентированногоУчета;
//						ДоговорКонтрагента.Комментарий
						ДоговорКонтрагента.Организация		= Организация;
//						ДоговорКонтрагента.ПроцентКомиссионногоВознаграждения
//						ДоговорКонтрагента.СпособРасчетаКомиссионногоВознаграждения
//						ДоговорКонтрагента.ТипЦен
						ДоговорКонтрагента.ВидДоговора		= Перечисления.ВидыДоговоровКонтрагентов.СПокупателем;
						ДоговорКонтрагента.УчетАгентскогоНДС		= Ложь;
//						ДоговорКонтрагента.ВидАгентскогоДоговора
						ДоговорКонтрагента.РасчетыВУсловныхЕдиницах	= Ложь;
						ДоговорКонтрагента.РеализацияНаЭкспорт		= Ложь;
//						ДоговорКонтрагента.ВидВзаиморасчетов
//						ДоговорКонтрагента.Дата
//						ДоговорКонтрагента.Номер
//						ДоговорКонтрагента.СрокДействия
//						ДоговорКонтрагента.УстановленСрокОплаты
//						ДоговорКонтрагента.СрокОплаты
//						ДоговорКонтрагента.НаименованиеДляСчетаФактурыНаАванс
						ДоговорКонтрагента.ПорядокРегистрацииСчетовФактурНаАвансПоДоговору	= Перечисления.ПорядокРегистрацииСчетовФактурНаАванс.НаВсеАвансы;
//						ДоговорКонтрагента.НалоговыйАгентПоОплате
//						ДоговорКонтрагента.ИспользуетсяПриОбменеДанными
						ДоговорКонтрагента.Записать();
						Договор	= ДоговорКонтрагента.Ссылка;
					КонецЕсли;
				КонецЕсли;
				
				Услуга		= Справочники.Номенклатура.НайтиПоНаименованию(descr);
				Если ЗначениеЗаполнено(Услуга) Тогда
					УслугаОбъект	= Справочники.Номенклатура.СоздатьЭлемент();
					УслугаОбъект.Наименование				= descr;
					УслугаОбъект.НаименованиеПолное			= descr;
//					УслугаОбъект.БазоваяЕдиницаИзмерения
					УслугаОбъект.СтавкаНДС					= СтавкаНДС;
//					УслугаОбъект.Комментарий
					УслугаОбъект.Услуга						= Истина;
//					УслугаОбъект.НоменклатурнаяГруппа
//					УслугаОбъект.СтранаПроисхождения
//					УслугаОбъект.НомерГТД
//					УслугаОбъект.СтатьяЗатрат
//					УслугаОбъект.ОсновнаяСпецификацияНоменклатуры
					УслугаОбъект.Записать();
					Услуга			= УслугаОбъект.Ссылка;
				КонецЕсли;
					
//Заполнение шапки документа РТУ
				Акт								= Документы.РеализацияТоваровУслуг.СоздатьДокумент();
				Акт.Дата				= Сред(op_date,0,4)+Сред(op_date,6,2)+Сред(op_date,9,2);//Сред(op_date,7,4)+Сред(op_date,4,2)+Сред(op_date,1,2);
//				Акт.АдресДоставки
//				Акт.БанковскийСчетОрганизации
				Акт.ВалютаДокумента		= мВалютаРегламентированногоУчета;
				Акт.ВидОперации			= Перечисления.ВидыОперацийРеализацияТоваров.ПродажаКомиссия;
//				Акт.Грузоотправитель
//				Акт.Грузополучатель
				Акт.ДоговорКонтрагента	= Договор;
				Акт.Комментарий			= СтрокаКомментария;
				Акт.Контрагент			= Контрагент;
				Акт.КратностьВзаиморасчетов		= 1;
				Акт.КурсВзаиморасчетов	= 1;
				Акт.Организация			= Организация;
//				Акт.Ответственный
//				Акт.Склад
//				Акт.СтатьяДоходовИРасходовПоТаре
				Акт.СуммаВключаетНДС	= Истина;
				Акт.СуммаДокумента		= Число(op_summa);
//				Акт.СчетУчетаДоходовПоТаре
//				Акт.СчетУчетаРасходовПоТаре
				Акт.СчетУчетаРасчетовПоАвансам		= СчетАвансов;
//				Акт.СчетУчетаРасчетовПоТаре
				Акт.СчетУчетаРасчетовСКонтрагентом	= СчетРасчетов;
//				Акт.ТипЦен
				//Акт.УчитыватьНДС		= Истина;
				Акт.РучнаяКорректировка	= Ложь;
//				Акт.СчетНаОплатуПокупателю
				Акт.СпособЗачетаАвансов	= Перечисления.СпособыЗачетаАвансов.Автоматически;
				
//Заполнение ТЧ Услуги документа РТУ
				НоваяСтрока	= Акт.Услуги.Добавить();
				НоваяСтрока.Содержание		= descr;
				НоваяСтрока.Количество		= 1;
				НоваяСтрока.Цена			= Число(op_summa);
				НоваяСтрока.Сумма			= Число(op_summa);
				НоваяСтрока.СтавкаНДС		= СтавкаНДС;
				НоваяСтрока.СуммаНДС		= Число(op_summa)*РасчетнаяСтавкаНДС;
				НоваяСтрока.Номенклатура	= Услуга;
				НоваяСтрока.СчетУчетаНДСПоРеализации	= ПланыСчетов.Хозрасчетный.Продажи_НДС;
				НоваяСтрока.СчетДоходов		= ПланыСчетов.Хозрасчетный.ВыручкаНеЕНВД;
				НоваяСтрока.СчетРасходов	= ПланыСчетов.Хозрасчетный.СебестоимостьПродажНеЕНВД;
//				НоваяСтрока.Субконто
				Акт.Записать();
					
//+SHDE
//				URL = АдресСервера+"/api.php?cmd=select&proc=API_FINOPER_SYNC&arg1="+Строка(suid)+
//						"&arg2="+Строка(op_id)+"&arg3="+Строка("A"+Строка(ДатаГод(Акт.ДатаДок))+"_"+Акт.НомерДок);
//				xml_ОтправитьЗапрос(URL);
//+Обработка результата запроса
//				xml_ПрочитатьЗапрос(ИмяФайла_подтв);
//				ФайлПодтв	= xml_ОткрытьФайл(ИмяФайла_подтв);
//				xml_ПрочитатьЗаголовок(ФайлПодтв);
//				xml_Закрыть(ФайлПодтв);
//-Обработка результата запроса

				НоваяСтрока		= тСинхронизации.Добавить();
				НоваяСтрока.code_asr	= Строка(op_id);
				НоваяСтрока.code_1c		= Строка(Формат(Год(Акт.Дата),"ЧГ=0")+"_"+Акт.Номер);

				Если тСинхронизации.Количество() = КолЗапСинхр Тогда
					ПровестиСинхронизацию(suid,3);
				КонецЕсли;
//-SHDE
				Сообщить("Создан акт об оказании услуг с кодом: " + Строка(Акт.Номер) + " от " + Строка(Акт.Дата));
			КонецЕсли;
		 конеццикла;	
		 //КонецЕсли;
	КонецЦикла;
	
//+SHDE
	ПровестиСинхронизацию(suid,3);
//-SHDE

	//xml_Закрыть(ФайлЗагрузки);
КонецПроцедуры

//***********************************************************************************************************
Процедура ВыгрузитьПКО(suid)
	
	ВыборкаПКО	= Документы.ПриходныйКассовыйОрдер.Выбрать(НачДата,КонДата);
	Пока ВыборкаПКО.Следующий() Цикл
		Если ВыборкаПКО.Проведен И ВыборкаПКО.ВидОперации = Перечисления.ВидыОперацийПКО.ОплатаПокупателя Тогда
			params=Новый Соответствие;
			params["abon_code1c"]=ВыборкаПКО.Контрагент.Код;
			params["op_date"]=Формат(ВыборкаПКО.Дата,"ДФ=yyyy-MM-dd");
			params["op_summa"]=Формат(ВыборкаПКО.СуммаДокумента,"ЧГ=0");
			params["descr"]="Касса: " + СокрЛП(ВыборкаПКО.Основание);
			params["code1c"]=Формат(Год(ВыборкаПКО.Дата),"ЧГ=0") + "_" + ВыборкаПКО.Номер;
			params["op_type_id"]= 2;
			счСтрок		= 1;
			ОтправитьФинОперацию(suid,params);
			Сообщить("Выгружен приходный кассовый ордер с номером: " + Строка(ВыборкаПКО.Номер));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры
Процедура ВыгрузитьПДС(suid)
	ИмяФайла	= КаталогВременныхФайлов() + "\tmp_export_finoper_add.xml";
	
	ВыборкаПДС	= Документы.ПоступлениеНаРасчетныйСчет.Выбрать(НачДата,КонДата);
	Пока ВыборкаПДС.Следующий() Цикл
		Если ВыборкаПДС.Проведен И ВыборкаПДС.ВидОперации = Перечисления.ВидыОперацийПоступлениеДенежныхСредств.ОплатаПокупателя Тогда
			params=Новый Структура;
			params.Вставить("abon_code1c", ВыборкаПДС.Контрагент.Код);
			params.Вставить("code1c", Формат(Год(ВыборкаПДС.Дата),"ЧГ=0") + "_" + ВыборкаПДС.Номер);
			params.Вставить("op_date", Формат(ВыборкаПДС.Дата,"ДФ=yyyy-MM-dd"));
			params.Вставить("op_summa", Формат(ВыборкаПДС.СуммаДокумента,"ЧГ=0"));
			params.Вставить("descr", "Банк: " + СтрЗаменить(СокрЛП(ВыборкаПДС.НазначениеПлатежа), Символ(34), "\"+Символ(34)));
			params.Вставить("pr_number", Формат(Год(ВыборкаПДС.Дата),"ЧГ=0") + "_" + Строка(ВыборкаПДС.Номер) + "_" + Строка(1));
			params.Вставить("op_type_id", 2);
			ОтправитьФинОперацию(suid,params);
			счСтрок		= 1;
			Сообщить("Выгружено поступление денежных средств с номером: " + Строка(ВыборкаПДС.Номер) + ", строка:" + Строка(1));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

//***********************************************************************************************************
Процедура КнопкаВыполнитьНажатие()
	suid=ИмяПользователя;
	Если suid <> "" Тогда
		//suid		= РеквизитыОбъекта.Получить("suid");
		//Сообщить("Авторизация на сервере прошла успешно");
		Сообщить("---------------------------Начало обмена данными---------------------------");

		Если Загружать1 = 1 Тогда
			Сообщить("---------------------Загрузка справочника контрагенты----------------------");
			ПрочитатьКонтрагентов(suid);
		КонецЕсли;
		Если Загружать2 = 1 Тогда
			Сообщить("--------------Загрузка приходных кассовых ордеров (op_id = 2)--------------");
			ПрочитатьПКО(suid);
		КонецЕсли;
		Если Загружать3 = 1 Тогда
			Сообщить("-----------------Загрузка актов оказания услуг (op_id = 1)-----------------");
			ПрочитатьАкт(suid,1,"Услуга доступа за период ");
			//Сообщить("-------Загрузка актов оказания услуг по прочим операциям (op_id = 7)-------");
			//ПрочитатьАкт(suid,7,"Доп. услуга ");
		КонецЕсли;
		Если Выгружать1 = 1 Тогда
			Сообщить("-----------------Выгрузка приходных кассовых ордеров-----------------------");
			ВыгрузитьПКО(suid);
		КонецЕсли;
		Если Выгружать2 = 1 Тогда
			Сообщить("-----------------Выгрузка платежных поручений входящих-----------------------");
			ВыгрузитьПДС(suid);
		КонецЕсли;
		Сообщить("---------------------------Конец обмена данными----------------------------");
	Иначе
		suid		= 0;
		Сообщить("Ошибка авторизации на сервере");
	КонецЕсли;

	//xml_Закрыть(ФайлЗагрузки);
КонецПроцедуры  


WinHttpRequest = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");